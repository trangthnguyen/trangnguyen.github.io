<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset="utf-8">
		<meta name="author" content="Trang Nguyen">
		<meta name="description" content="This includes Trang Nguyen's Django learning notes.">
		<title>Trang's Django learning notes</title>
		<link href="../style.css" rel="stylesheet" type="text/css">
        <link href="../style-book.css" rel="stylesheet" type="text/css">
        <script src="../script.js" defer></script>
		<link rel="shortcut icon" href="../firefly.ico" type="image/x-icon">
	</head>
	<body>
        <header>
            <div id="headerbar">
                <div id="menubutton">
                    <button>Menu</button>
                </div>
                
                <div id="menu">
                    <a href="https://trangthnguyen.github.io/" id="home">Home</a>
                    <a href="https://trangthnguyen.github.io/django/">Django</a>
                    <a href="https://trangthnguyen.github.io/django/">Javascript</a>
                </div>
                
                <div id="sitename">
                    <a href="https://trangthnguyen.github.io/">
                        <p id="name"><code>Trang Nguyen</code></p>
                        <p id="site"><code>github site</code></p>
                    </a>
                </div>
                
                <div id="disclaimer">
                    <p>Disclaimer: Hi there! This is my personal github website, where I keep notes of various things that I am interested in. They may also be useful for you. However, please remember you use them at your own risk. I shall not be responsible for the accuracy of the information on the website or any consequences that you may encounter from using the information.</p>
                </div>
            </div>
            
            <div id="intro">
            </div>
        </header>
        
        <main>
            <div class="toc">
                <p id="tableofcontents">Table of contents</p>

            </div>
            
            <div class="maincontent">
                <h1 class="heading">
                    <span id="jQuery">jQuery</span>
                    <span class="source"><a href="https://learn.jquery.com/about-jquery/">Source</a></span>
                </h1>
                <div class="content">
                    <h2 class="heading">
                        <span id="About-jQuery">About jQuery</span>
                        <span class="source"><a href="https://learn.jquery.com/about-jquery/">Source</a></span>
                    </h2>
                    <div class="content">
                        <p>One important thing to know is that jQuery is just a JavaScript library. All the power of jQuery is accessed via JavaScript, so having a strong grasp of JavaScript is essential for understanding, structuring, and debugging your code.</p>
                    </div>
                    
                    <h2 class="heading">
                        <span id="Using-jQuery-Core">Using jQuery Core</span>
                        <span class="source"><a href="https://learn.jquery.com/using-jquery-core/">Source</a></span>
                    </h2>
                    <div class="content">
                        <h3 class="heading">
                            <span id="jQuery-The-Basics">jQuery: The Basics - Download and include</span>
                            <span class="source"><a href="https://learn.jquery.com/about-jquery/how-jquery-works/#jquery-the-basics">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>Include jQuery in your html:</p>

                            <pre><code>
                            &lt;!doctype html>
                            &lt;html>
                            &lt;head>
                                &lt;meta charset="utf-8">
                                &lt;title>Demo&lt;/title>
                            &lt;/head>
                            &lt;body>
                                &lt;a href="http://jquery.com/">jQuery&lt;/a>
                                &lt;script src="jquery.js">&lt;/script>
                                &lt;script>

                                // Your code goes here.

                                &lt;/script>
                            &lt;/body>
                            &lt;/html>
                            </code></pre>

                            <p>The <code>src</code> attribute in the <code>&lt;script></code> element must point to a copy of jQuery. Download a copy of jQuery from the <a href="https://jquery.com/download/">Downloading jQuery page</a> and store the <code>jquery.js</code> file in the same directory as your HTML file. Note: When you download jQuery, the file name may contain a version number, e.g., <code>jquery-x.y.z.js</code>. Make sure to either rename this file to <code>jquery.js</code> or update the <code>src</code> attribute of the <code>&lt;script></code> element to match the file name.</p>
                        </div>

                        <h3 class="heading">
                            <span id="The-jQuery-Object">The jQuery Object</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/jquery-object/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="DOM-and-DOM-Elements">DOM and DOM Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/jquery-object/#dom-and-dom-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The Document Object Model (DOM for short) is a representation of an HTML document. It may contain any number of DOM elements. At a high level, a DOM element can be thought of as a "piece" of a web page. It may contain text and/or other DOM elements.</p> 

                                <p>DOM elements are described by a type, such as <code>&lt;div></code>, <code>&lt;a></code>, or <code>&lt;p></code>, and any number of attributes such as <code>src</code>, <code>href</code>, <code>class</code> and so on. For a more thorough description, refer to the <a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-745549614">official DOM specification</a> from the W3C.</p>

                                <p>Elements have properties like any JavaScript object. Among these properties are attributes like <code>.tagName</code> and methods like <code>.appendChild()</code>. These properties are the only way to interact with the web page via JavaScript.</p>
                            </div>

                            <h4 class="heading">
                                <span id="The-jQuery-Object-sub">The jQuery Object</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/jquery-object/#the-jquery-object">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>It turns out that working directly with DOM elements can be awkward. The jQuery object defines many methods to smooth out the experience for developers. Some benefits of the jQuery Object include:</p>

                                <ul>
                                    <li><em>Compatibility:</em></li>
                                        <ul>
                                            <li>The implementation of element methods varies across browser vendors and versions. The following snippet attempts to set the inner HTML of a <code>&lt;tr></code> element stored in target:</li>
                                            <pre><code>
                                            var target = document.getElementById( "target" );

                                            target.innerHTML = "<td>Hello <b>World</b>!</td>";
                                            </code></pre>
                                            <p>This works in many cases, but it will fail in most versions of Internet Explorer. In that case, the recommended approach is to use pure DOM methods instead.</p>
                                            <li>By wrapping the <code>target</code> element in a jQuery object, these edge cases are taken care of, and the expected result is achieved in all supported browsers:</li>
                                            <pre><code>
                                            // Setting the inner HTML with jQuery.

                                            var target = document.getElementById( "target" );

                                            $( target ).html( "<td>Hello <b>World</b>!</td>" );
                                            </code></pre>
                                        </ul>
                                    <li><em>Convenience:</em></li>
                                        <ul>
                                            <li>There are also a lot of common DOM manipulation use cases that are awkward to accomplish with pure DOM methods. For instance, inserting an element stored in <code>newElement</code> after the <code>target</code> element requires a rather verbose DOM method:</li>
                                            <pre><code>
                                            // Inserting a new element after another with the native DOM API.

                                            var target = document.getElementById( "target" );

                                            var newElement = document.createElement( "div" );

                                            target.parentNode.insertBefore( newElement, target.nextSibling );
                                            </code></pre>

                                            <li>By wrapping the <code>target</code> element in a jQuery object, the same task becomes much simpler:</li>
                                            <pre><code>
                                            // Inserting a new element after another with jQuery.

                                            var target = document.getElementById( "target" );

                                            var newElement = document.createElement( "div" );

                                            $( target ).after( newElement );
                                            </code></pre>
                                        </ul>
                                </ul>

                                <h5 class="heading">
                                    <span id="Getting-Elements-Into-the-jQuery-Object">Getting Elements Into the jQuery Object</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/jquery-object/#getting-elements-into-the-jquery-object">Source</a></span>
                                </h5>
                                <div class="content">
                                    <ul>
                                        <li>When the jQuery function is invoked with a CSS selector, it will return a jQuery object wrapping any element(s) that match this selector. For instance, writing:</li>
                                        <pre><code>
                                        // Selecting all &lt;h1> tags.

                                        var headings = $( "h1" );
                                        </code></pre>
                                        <code>headings</code> is now a jQuery element containing all the <code>&lt;h1></code> tags already on the page.
                                        <ul>
                                            <li>This can be verified by inspecting the <code>.length</code> property of <code>headings</code>:</li>
                                            <pre><code>
                                            // Viewing the number of &lt;h1> tags on the page.

                                            var headings = $( "h1" );

                                            alert( headings.length );
                                            </code></pre>
                                            <p>If the page has more than one <code>&lt;h1></code> tag, this number will be greater than one. If the page has no <code>&lt;h1></code> tags, the .length property will be zero. Checking the .length property is a common way to ensure that the selector successfully matched one or more elements.</p>
                                        </ul>

                                        <li>If the goal is to select only the first heading element, another step is required. There are a number of ways to accomplish this, but the most straight-forward is the <code>.eq()</code> function.</li>
                                        <pre><code>
                                        // Selecting only the first &lt;h1> element on the page (in a jQuery object)

                                        var headings = $( "h1" );

                                        var firstHeading = headings.eq( 0 );
                                        </code></pre>
                                        <ul>
                                            <li>Now <code>firstHeading</code> is a jQuery object containing only the first <code>&lt;h1></code> element on the page.</li>
                                            <li>And because <code>firstHeading</code> is a jQuery object, it has useful methods like <code>.html()</code> and <code>.after()</code>.</li>
                                        </ul>

                                        <li>jQuery also has a method named <code>.get()</code> which provides a related function. Instead of returning a jQuery-wrapped DOM element, it returns the DOM element itself.</li>
                                        <pre><code>
                                        // Selecting only the first &lt;h1> element on the page.

                                        var firstHeadingElem = $( "h1" ).get( 0 );
                                        </code></pre>

                                        <p>Alternatively, because the jQuery object is "array-like," it supports array subscripting via brackets:</p>
                                        <pre><code>
                                        // Selecting only the first &lt;h1> element on the page (alternate approach).

                                        var firstHeadingElem = $( "h1" )[ 0 ];
                                        </code></pre>
                                        <ul>
                                            <li>In either case, <code>firstHeadingElem</code> contains the native DOM element. This means it has DOM properties like <code>.innerHTML</code> and methods like <code>.appendChild()</code>, but not jQuery methods like <code>.html()</code> or <code>.after()</code>.</li>

                                            <li>The <code>firstHeadingElem</code> element is more difficult to work with, but there are certain instances that require it. One such instance is making comparisons.</li>
                                        </ul>
                                    </ul>
                                </div>

                                <h5 class="heading">
                                    <span id="Not-All-jQuery-Objects-are-Created">Not All jQuery Objects are Created ===</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/jquery-object/#not-all-jquery-objects-are-created">Source</a></span>
                                </h5>
                                <div class="content">
                                    <ul>
                                        <li>An important detail regarding this "wrapping" behavior is that each wrapped object is unique. This is true even if the object was created with the same selector or contain references to the exact same DOM elements.</li>
                                        <pre><code>
                                        // Creating two jQuery objects for the same element.

                                        var logo1 = $( "#logo" );
                                        var logo2 = $( "#logo" );
                                        </code></pre>

                                        <p>Although <code>logo1</code> and <code>logo2</code> are created in the same way (and wrap the same DOM element), they are not the same object. For example:</p>
                                        <pre><code>
                                        // Comparing jQuery objects.

                                        alert( $( "#logo" ) === $( "#logo" ) ); // alerts "false"
                                        </code></pre>

                                        <p>However, both objects contain the same DOM element. The <code>.get()</code> method is useful for testing if two jQuery objects have the same DOM element.</p>
                                        <pre><code>
                                        // Comparing DOM elements.

                                        var logo1 = $( "#logo" );
                                        var logo1Elem = logo1.get( 0 );

                                        var logo2 = $( "#logo" );
                                        var logo2Elem = logo2.get( 0 );

                                        alert( logo1Elem === logo2Elem ); // alerts "true"
                                        </code></pre>

                                        <li>Many developers prefix a <code>$</code> to the name of variables that contain jQuery objects in order to help differentiate. There is nothing magic about this practice – it just helps some people keep track of what different variables contain. The previous example could be re-written to follow this convention:</li>
                                        <pre><code>
                                        // Comparing DOM elements (with more readable variable names).

                                        var $logo1 = $( "#logo" );
                                        var logo1 = $logo1.get( 0 );

                                        var $logo2 = $( "#logo" );
                                        var logo2 = $logo2.get( 0 );

                                        alert( logo1 === logo2 ); // alerts "true"
                                        </code></pre>

                                        <p>This code functions identically to the example above, but it is a little more clear to read.</p>

                                        <li>Regardless of the naming convention used, it is very important to make the distinction between jQuery object and native DOM elements. Native DOM methods and properties are not present on the jQuery object, and vice versa. Error messages like <code>"event.target.closest is not a function"'</code> and <code>"TypeError: Object [object Object] has no method 'setAttribute'"</code> indicate the presence of this common mistake.</li>
                                    </ul>
                                </div>

                                <h5 class="heading">
                                    <span id="jQuery-Objects-Are-Not-Live">jQuery Objects Are Not "Live"</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/jquery-object/#jquery-objects-are-not-quot-live-quot">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>Given a jQuery object with all the paragraph elements on the page:</p>
                                    <pre><code>
                                    // Selecting all &lt;p> elements on the page.

                                    var allParagraphs = $( "p" );
                                    </code></pre>
                                    <p>…one might expect that the contents will grow and shrink over time as <code>&lt;p></code> elements are added and removed from the document. jQuery objects do NOT behave in this manner. The set of elements contained within a jQuery object will not change unless explicitly modified. This means that the collection is not "live" – it does not automatically update as the document changes. If the document may have changed since the creation of the jQuery object, the collection should be updated by creating a new one. It can be as easy as re-running the same selector:</p>
                                    <pre><code>
                                    // Updating the selection.

                                    allParagraphs = $( "p" );
                                    </code></pre>
                                </div>
                            </div>
                        </div>

                        <h3 class="heading">
                            <span id="dollar-object-vs-function"><code>$</code> vs <code>$()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/dollar-object-vs-function/">Source</a></span>
                        </h3>
                        <div class="content">
                            <ul>
                                <li>Until now, we've been dealing entirely with methods that are called on a jQuery object. For example:</li>
                                <pre><code>
                                $( "h1" ).remove();
                                </code></pre>

                                <p>Most jQuery methods are called on jQuery objects as shown above; these methods are said to be part of the <code>$.fn</code> namespace, or the "jQuery prototype," and are best thought of as jQuery object methods.</p>

                                <li>However, there are several methods that do not act on a selection; these methods are said to be part of the jQuery namespace, and are best thought of as core jQuery methods.</li>

                                <li>This distinction can be incredibly confusing to new jQuery users. Here's what you need to remember:</li>
                                <ul>
                                    <li>Methods called on jQuery selections are in the <code>$.fn</code> namespace, and automatically receive and return the selection as <code>this</code>.</li>
                                    <li>Methods in the <code>$</code> namespace are generally utility-type methods, and do not work with selections; they are not automatically passed any arguments, and their return value will vary.</li>
                                </ul>

                                <li>There are a few cases where object methods and core methods have the same names, such as <code>$.each()</code> and <code>.each()</code>. In these cases, be extremely careful when reading the documentation that you are exploring the correct method.</li>

                                <p>In this guide, if a method can be called on a jQuery selection, we'll refer to it just by its name: <code>.each()</code>. If it is a utility method -- that is, a method that isn't called on a selection -- we'll refer to it explicitly as a method in the jQuery namespace: <code>$.each()</code>.</p>
                            </ul>
                        </div>

                        <h3 class="heading">
                            <span id="Launching-Code-on-Document-Ready">Launching Code on Document Ready</span>
                            <span class="source"><a href="https://learn.jquery.com/about-jquery/how-jquery-works/#launching-code-on-document-ready">Source 1</a></span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/document-ready/">Source 2</a></span>
                        </h3>
                        <div class="content">
                            <ul>
                                <li>To ensure that their code runs after the browser finishes loading the document, many JavaScript programmers wrap their code in an onload function:</li>
                                <pre><code>
                                window.onload = function() {

                                    alert( "welcome" );

                                };
                                </code></pre>

                                <p>Unfortunately, the code doesn't run until all images are finished downloading, including banner ads.</p> 

                                <li>To run code as soon as the document is ready to be manipulated, jQuery has a statement known as the ready event:</li>
                                <pre><code>
                                $( document ).ready(function() {

                                    // Your code here.

                                });
                                </code></pre>

                                <ul>
                                    <li>Experienced developers sometimes use the shorthand <code>$()</code> for <code>$( document ).ready()</code>. If you are writing code that people who aren't experienced with jQuery may see, it's best to use the long form.</li>
                                    <pre><code>
                                    // Shorthand for $( document ).ready()
                                    $(function() {
                                        console.log( "ready!" );
                                    });
                                    </code></pre>

                                    <li>You can also pass a named function to <code>$( document ).ready()</code> instead of passing an anonymous function.</li>
                                    <pre><code>
                                    // Passing a named function instead of an anonymous function.

                                    function readyFn( jQuery ) {
                                        // Code to run when the document is ready.
                                    }

                                    $( document ).ready( readyFn );
                                    // or:
                                    $( window ).on( "load", readyFn );
                                    </code></pre>
                                </ul>

                            </ul>
                            <p>Note: The jQuery library exposes its methods and properties via two properties of the <code>window</code> object called <code>jQuery</code> and <code>$</code>. <code>$</code> is simply an alias for jQuery and it's often employed because it's shorter and faster to write.</p>
                        </div>

                        <h3 class="heading">
                            <span id="Avoiding-Conflicts-with-Other-Libraries">Avoiding Conflicts with Other Libraries</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>The jQuery library and virtually all of its plugins are contained within the jQuery namespace. As a general rule, global objects are stored inside the jQuery namespace as well, so you shouldn't get a clash between jQuery and any other library (like prototype.js, MooTools, or YUI).</p>

                            <p>That said, there is one caveat: by default, jQuery uses <code>$</code> as a shortcut for jQuery. Thus, if you are using another JavaScript library that uses the <code>$</code> variable, you can run into conflicts with jQuery. In order to avoid these conflicts, you need to put jQuery in no-conflict mode immediately after it is loaded onto the page and before you attempt to use jQuery in your page.</p>

                            <h4 class="heading">
                                <span id="Putting-jQuery-Into-No-Conflict-Mode">Putting jQuery Into No-Conflict Mode</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/#putting-jquery-into-no-conflict-mode">Source</a></span>
                            </h4>
                            <div class="content">
                                <ul>
                                    <li>When you put jQuery into no-conflict mode, you have the option of assigning a new variable name to replace the <code>$</code> alias.</li>
                                    <pre><code>
                                    &lt;!-- Putting jQuery into no-conflict mode. -->
                                    &lt;script src="prototype.js">&lt;/script>
                                    &lt;script src="jquery.js">&lt;/script>
                                    &lt;script>

                                    var $j = jQuery.noConflict();
                                    // $j is now an alias to the jQuery function; creating the new alias is optional.

                                    $j(document).ready(function() {
                                        $j( "div" ).hide();
                                    });

                                    // The $ variable now has the prototype meaning, which is a shortcut for
                                    // document.getElementById(). mainDiv below is a DOM element, not a jQuery object.
                                    window.onload = function() {
                                        var mainDiv = $( "main" );
                                    }

                                    &lt;/script>
                                    </code></pre>

                                    <p>In the code above, the <code>$</code> will revert back to its meaning in original library. You'll still be able to use the full function name jQuery as well as the new alias <code>$j</code> in the rest of your application. The new alias can be named anything you'd like: <code>jq</code>, <code>$J</code>, <code>awesomeQuery</code>, etc.</p>

                                    <li>Finally, if you don't want to define another alternative to the full jQuery function name (you really like to use <code>$</code> and don't care about using the other library's <code>$</code> method), then there's still another approach you might try: simply add the <code>$</code> as an argument passed to your <code>jQuery( document ).ready()</code> function. This is most frequently used in the case where you still want the benefits of really concise jQuery code, but don't want to cause conflicts with other libraries.</li>
                                    <pre><code>
                                    &lt;!-- Another way to put jQuery into no-conflict mode. -->
                                    &lt;script src="prototype.js">&lt;/script>
                                    &lt;script src="jquery.js">&lt;/script>
                                    &lt;script>

                                    jQuery.noConflict();

                                    jQuery( document ).ready(function( $ ) {
                                        // You can use the locally-scoped $ in here as an alias to jQuery.
                                        $( "div" ).hide();
                                    });

                                    // The $ variable in the global scope has the prototype.js meaning.
                                    window.onload = function(){
                                        var mainDiv = $( "main" );
                                    }

                                    &lt;/script>
                                    </code></pre>
                                    <p>This is probably the ideal solution for most of your code, considering that there'll be less code that you'll have to change in order to achieve complete compatibility.</p>
                                </ul>
                            </div>

                            <h4 class="heading">
                                <span id="Including-jQuery-Before-Other-Libraries">Including jQuery Before Other Libraries</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/#including-jquery-before-other-libraries">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The code snippets above rely on jQuery being loaded after <code>prototype.js</code> is loaded. If you include jQuery before other libraries, you may use jQuery when you do some work with jQuery, but the <code>$</code> will have the meaning defined in the other library. There is no need to relinquish the <code>$</code> alias by calling <code>jQuery.noConflict()</code>.</p>
                                <pre><code>
                                &lt;!-- Loading jQuery before other libraries. -->
                                &lt;script src="jquery.js">&lt;/script>
                                &lt;script src="prototype.js">&lt;/script>
                                &lt;script>

                                // Use full jQuery function name to reference jQuery.
                                jQuery( document ).ready(function() {
                                    jQuery( "div" ).hide();
                                });

                                // Use the $ variable as defined in prototype.js
                                window.onload = function() {
                                    var mainDiv = $( "main" );
                                };

                                &lt;/script>
                                </code></pre>
                            </div>

                            <h4 class="heading">
                                <span id="Summary-of-Ways-to-Reference-the-jQuery-Function">Summary of Ways to Reference the jQuery Function</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/#summary-of-ways-to-reference-the-jquery-function">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Here's a recap of ways you can reference the jQuery function when the presence of another library creates a conflict over the use of the <code>$</code> variable:</p>

                                <h5 class="heading">
                                    <span id="Create-a-New-Alias">Create a New Alias</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/#create-a-new-alias">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>The <code>jQuery.noConflict()</code> method returns a reference to the jQuery function, so you can capture it in whatever variable you'd like:</p>
                                    <pre><code>
                                    &lt;script src="prototype.js">&lt;/script>
                                    &lt;script src="jquery.js">&lt;/script>
                                    &lt;script>

                                    // Give $ back to prototype.js; create new alias to jQuery.
                                    var $jq = jQuery.noConflict();

                                    &lt;/script>
                                    </code></pre>
                                </div>

                                <h5 class="heading">
                                    <span id="Use-an-Immediately-Invoked-Function-Expression">Use an Immediately Invoked Function Expression</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/#use-an-immediately-invoked-function-expression">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>You can continue to use the standard <code>$</code> by wrapping your code in an immediately invoked function expression; this is also a standard pattern for jQuery plugin authoring, where the author cannot know whether another library will have taken over the <code>$</code>. See the <a href="https://learn.jquery.com/plugins/">Plugins</a> section for more information about writing plugins.</p>
                                    <pre><code>
                                    &lt;!-- Using the $ inside an immediately-invoked function expression. -->
                                    &lt;script src="prototype.js">&lt;/script>
                                    &lt;script src="jquery.js">&lt;/script>
                                    &lt;script>

                                    jQuery.noConflict();

                                    (function( $ ) {
                                        // Your jQuery code here, using the $
                                    })( jQuery );

                                    &lt;/script>
                                    </code></pre>

                                    <p>Note that if you use this technique, you will not be able to use <code>prototype.js</code> methods inside the immediately invoked function. <code>$</code> will be a reference to jQuery, not <code>prototype.js</code>.</p>
                                </div>

                                <h5 class="heading">
                                    <span id="Use-the-Argument-That-s-Passed-to-the-jQuery-document-ready-Function">Use the Argument That's Passed to the <code>jQuery( document ).ready()</code> Function</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/avoid-conflicts-other-libraries/#use-the-argument-that-39-s-passed-to-the-jquery-document-ready-function">Source</a></span>
                                </h5>
                                <div class="content">
                                    <pre><code>
                                    &lt;script src="jquery.js">&lt;/script>
                                    &lt;script src="prototype.js">&lt;/script>
                                    &lt;script>

                                    jQuery(document).ready(function( $ ) {
                                        // Your jQuery code here, using $ to refer to jQuery.
                                    });

                                    &lt;/script>
                                    </code></pre>

                                    <p>Or using the more concise syntax for the DOM ready function:</p>
                                    <pre><code>
                                    &lt;script src="jquery.js">&lt;/script>
                                    &lt;script src="prototype.js">&lt;/script>
                                    &lt;script>

                                    jQuery(function($){
                                        // Your jQuery code here, using the $
                                    });

                                    &lt;/script>
                                    </code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Attributes">Attributes</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/attributes/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="The-attr-method">The <code>.attr()</code> method</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/attributes/#the-attr-method">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The <code>.attr()</code> method acts as both a getter and a setter</p>
                                
                                <ul>
                                    <li><code>.attr()</code> as a setter: As a setter, <code>.attr()</code> can accept either a key and a value, or an object containing one or more key/value pairs.</li>
                                    <pre><code>
                                    $( "a" ).attr( "href", "allMyHrefsAreTheSameNow.html" );
 
                                    $( "a" ).attr({
                                        title: "all titles are the same too!",
                                        href: "somethingNew.html"
                                    });
                                    </code></pre>
                                    
                                    <li><code>.attr()</code> as a getter:</li>
                                    <pre><code>
                                    $( "a" ).attr( "href" ); // Returns the href for the first a element in the document
                                    </code></pre>
                                </ul>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Selecting-Elements">Selecting Elements</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="Selecting-elements-using-CSS-selectors">Selecting elements using CSS selectors</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The most basic concept of jQuery is to "select some elements and do something with them." jQuery supports most CSS3 selectors, as well as some non-standard selectors. For a complete selector reference, visit the <a href="http://api.jquery.com/category/selectors/">Selectors documentation on api.jquery.com</a>.</p>
                                
                                <ul>
                                    <li>Selecting Elements by ID</li>
                                    <pre><code>
                                    $( "#myId" ); // Note IDs must be unique per page.
                                    </code></pre>
                                    
                                    <li>Selecting Elements by Class Name</li>
                                    <pre><code>
                                    $( ".myClass" );
                                    </code></pre>
                                    
                                    <li>Selecting Elements by Attribute</li>
                                    <pre><code>
                                    $( "input[name='first_name']" );
                                    </code></pre>
                                    
                                    <li>Selecting Elements by Compound CSS Selector</li>
                                    <pre><code>
                                    $( "#contents ul.people li" );
                                    </code></pre>
                                    
                                    <li>Selecting Elements with a Comma-separated List of Selectors</li>
                                    <pre><code>
                                    $( "div.myClass, ul.people" );
                                    </code></pre>
                                    
                                    <li>Pseudo-Selectors</li>
                                    <pre><code>
                                    $( "a.external:first" );
                                    $( "tr:odd" );

                                    // Select all input-like elements in a form (more on this below).
                                    $( "#myForm :input" );
                                    $( "div:visible" );

                                    // All except the first three divs.
                                    $( "div:gt(2)" );

                                    // All currently animated divs.
                                    $( "div:animated" );
                                    </code></pre>
                                    
                                    <ul>
                                        <li>Note: When using the <code>:visible</code> and <code>:hidden</code> pseudo-selectors, jQuery tests the actual visibility of the element, not its CSS visibility or display properties. jQuery looks to see if the element's physical height and width on the page are both greater than zero. However, this test doesn't work with <code>&lt;tr></code> elements. In the case of <code>&lt;tr></code> jQuery does check the CSS display property, and considers an element hidden if its <code>display</code> property is set to <code>none</code>.</li>
                                        
                                        <li>Elements that have not been added to the DOM will always be considered hidden, even if the CSS that would affect them would render them visible. See the <a href="https://learn.jquery.com/manipulating-elements">Manipulating Elements</a> section to learn how to create and add elements to the DOM.</li>
                                    </ul>
                                </ul>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Choosing-Selectors">Choosing Selectors</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/#choosing-selectors">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Choosing good selectors is one way to improve JavaScript's performance. Too much specificity can be a bad thing. A selector such as <code>#myTable thead tr th.special</code> is overkill if a selector such as <code>#myTable th.special</code> will get the job done.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Does-My-Selection-Contain-Any-Elements">Does My Selection Contain Any Elements?</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/#does-my-selection-contain-any-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Once you've made a selection, you'll often want to know whether you have anything to work with.</p>
                                
                                <ul>
                                    <li>A common mistake is to use:</li>
                                    <pre><code>
                                    // Doesn't work!
                                    if ( $( "div.foo" ) ) {
                                        ...
                                    }
                                    </code></pre>
                                    <p>This won't work. When a selection is made using <code>$()</code>, an object is always returned, and objects always evaluate to <code>true</code>. Even if the selection doesn't contain any elements, the code inside the <code>if</code> statement will still run.</p>
                                    
                                    <li>The best way to determine if there are any elements is to test the selection's <code>.length</code> property, which tells you how many elements were selected. If the answer is 0, the <code>.length</code> property will evaluate to <code>false</code> when used as a boolean value:</li>
                                    <pre><code>
                                    // Testing whether a selection contains elements.
                                    if ( $( "div.foo" ).length ) {
                                        ...
                                    }
                                    </code></pre>
                                </ul>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Saving-Selections">Saving Selections</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/#saving-selections">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery doesn't cache elements for you. If you've made a selection that you might need to make again, you should save the selection in a variable rather than making the selection repeatedly.</p>
                                <pre><code>
                                var divs = $( "div" );
                                </code></pre>
                                
                                <p>Once the selection is stored in a variable, you can call jQuery methods on the variable just like you would have called them on the original selection.</p>
                                
                                <p>A selection only fetches the elements that are on the page at the time the selection is made. If elements are added to the page later, you'll have to repeat the selection or otherwise add them to the selection stored in the variable. Stored selections don't magically update when the DOM changes.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Refining-Filtering-Selections">Refining & Filtering Selections</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/#refining-amp-filtering-selections">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Sometimes the selection contains more than what you're after. jQuery offers several methods for refining and filtering selections.</p>
                                <pre><code>
                                // Refining selections.
                                $( "div.foo" ).has( "p" );         // div.foo elements that contain &lt;p> tags
                                $( "h1" ).not( ".bar" );           // h1 elements that don't have a class of bar
                                $( "ul li" ).filter( ".current" ); // unordered list items with class of current
                                $( "ul li" ).first();              // just the first unordered list item
                                $( "ul li" ).eq( 5 );              // the sixth
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Selecting-Form-Elements">Selecting Form Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/selecting-elements/#selecting-form-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery offers several pseudo-selectors that help find elements in forms. These are especially helpful because it can be difficult to distinguish between form elements based on their state or type using standard CSS selectors.</p>
                                
                                <ul>
                                    <li><code>:checked</code></li>
                                    
                                    <p>Not to be confused with <code>:checkbox</code>, <code>:checked</code> targets checked checkboxes, but keep in mind that this selector works also for checked radio buttons, and <code>&lt;select></code>code> elements (for <code>&lt;select></code> elements only, use the <code>:selected</code> selector):</p>
                                    <pre><code>
                                    $( "form :checked" );
                                    </code></pre>
                                    
                                    <p>The <code>:checked</code> pseudo-selector works when used with checkboxes, radio buttons and selects.</p>
                                    
                                    <li><code>:disabled</code></li>
                                    
                                    <p>Using the <code>:disabled</code> pseudo-selector targets any <code>&lt;input></code> elements with the <code>disabled</code> attribute:</p>
                                    <pre><code>
                                    $( "form :disabled" );
                                    </code></pre>
                                    
                                    <p>In order to get the best performance using <code>:disabled</code>, first select elements with a standard jQuery selector, then use <code>.filter( ":disabled" )</code>, or precede the pseudo-selector with a tag name or some other selector.</p>
                                    
                                    <li><code>:enabled</code></li>
                                    
                                    <p>Basically the inverse of the <code>:disabled</code> pseudo-selector, the <code>:enabled</code> pseudo-selector targets any elements that do not have a disabled attribute:</p>
                                    <pre><code>
                                    $( "form :enabled" );
                                    </code></pre>
                                    
                                    <p>In order to get the best performance using <code>:enabled</code>, first select elements with a standard jQuery selector, then use <code>.filter( ":enabled" )</code>, or precede the pseudo-selector with a tag name or some other selector.</p>
                                    
                                    <li><code>:input</code></li>
                                    
                                    <p>Using the <code>:input</code> selector selects all <code>&lt;input></code>, <code>&lt;textarea></code>code>, <code>&lt;select></code>code>, and <code>&lt;button></code>code> elements:</p>
                                    <pre><code>
                                    $( "form :input" );
                                    </code></pre>
                                    
                                    <li><code>:selected</code></li>
                                    
                                    <p>Using the <code>:selected</code> pseudo-selector targets any selected items in <code>&lt;option></code>code> elements:</p>
                                    <pre><code>
                                    $( "form :selected" );
                                    </code></pre>
                                    
                                    <p>In order to get the best performance using <code>:selected</code>, first select elements with a standard jQuery selector, then use <code>.filter( ":selected" )</code>, or precede the pseudo-selector with a tag name or some other selector.</p>
                                    
                                    <li>Selecting by type</li>
                                    <p>jQuery provides pseudo selectors to select form-specific elements according to their type:</p>
                                    <ul>
                                        <li><code>:password</code></li>
                                        <li><code>:reset</code></li>
                                        <li><code>:radio</code></li>
                                        <li><code>:text</code></li>
                                        <li><code>:submit</code></li>
                                        <li><code>:checkbox</code></li>
                                        <li><code>:button</code></li>
                                        <li><code>:image</code></li>
                                        <li><code>:file</code></li>
                                    </ul>
                                </ul>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Working-with-Selections">Working with Selections</span>
                            <span class="source"><a href="hhttps://learn.jquery.com/using-jquery-core/working-with-selections/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="Getters-Setters">Getters & Setters</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/working-with-selections/#getters-amp-setters">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Some jQuery methods can be used to either assign or read some value on a selection.</p>
                                
                                <ul>
                                    <li>When the method is called with a value as an argument, it's referred to as a setter because it sets (or assigns) that value. When the method is called with no argument, it gets (or reads) the value of the element.</li>
                                    
                                    <li>Setters affect all elements in a selection, whereas getters return the requested value only for the first element in the selection, with the exception of <code>.text()</code>, which retrieves the values of all the elements.</li>
                                    <pre><code>
                                    // The .html() method sets all the h1 elements' html to be "hello world":
                                    $( "h1" ).html( "hello world" );

                                    // The .html() method returns the html of the first h1 element:
                                    $( "h1" ).html();
                                    // > "hello world"
                                    </code></pre>
                                    
                                    <li>Setters return a jQuery object, allowing you to continue calling jQuery methods on your selection. Getters return whatever they were asked to get, so you can't continue to call jQuery methods on the value returned by the getter.</li>
                                    <pre><code>
                                    // Attempting to call a jQuery method after calling a getter.
                                    // This will NOT work:
                                    $( "h1" ).html().addClass( "test" );
                                    </code></pre>
                                </ul>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Chaining">Chaining</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/working-with-selections/#chaining">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>If you call a method on a selection and that method returns a jQuery object, you can continue to call jQuery methods on the object without pausing for a semicolon. This practice is referred to as "chaining":</p>
                                <pre><code>
                                $( "#content" ).find( "h3" ).eq( 2 ).html( "new text for the third h3!" );
                                </code></pre>
                                
                                <p>It may help code readability to break the chain over several lines:</p>
                                <pre><code>
                                $( "#content" )
                                    .find( "h3" )
                                    .eq( 2 )
                                    .html( "new text for the third h3!" );
                                </code></pre>
                                
                                <p>jQuery also provides the <code>.end()</code> method to get back to the original selection should you change the selection in the middle of a chain:</p>
                                <pre><code>
                                $( "#content" )
                                    .find( "h3" )
                                    .eq( 2 )
                                        .html( "new text for the third h3!" )
                                        .end() // Restores the selection to all h3s in #content
                                    .eq( 0 )
                                        .html( "new text for the first h3!" );
                                </code></pre>
                                
                                <p>Chaining is extraordinarily powerful, and it's a feature that many libraries have adapted since it was made popular by jQuery. However, it must be used with care – extensive chaining can make code extremely difficult to modify or debug. There is no hard-and-fast rule to how long a chain should be – just know that it's easy to get carried away.</p>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Manipulating-Elements">Manipulating Elements</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="Getting-and-Setting-Information-About-Elements">Getting and Setting Information About Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/#getting-and-setting-information-about-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Here are a few methods you can use to get and set information about elements:</p>
                                
                                <ul>
                                    <li><code>.html()</code> – Get or set the HTML contents.</li>
                                    <li><code>.text()</code> – Get or set the text contents; HTML will be stripped.</li>
                                    <li><code>.attr()</code> – Get or set the value of the provided attribute.</li>
                                    <li><code>.width()</code> – Get or set the width in pixels of the first element in the selection as an integer.</li>
                                    <li><code>.height()</code> – Get or set the height in pixels of the first element in the selection as an integer.</li>
                                    <li><code>.position()</code> – Get an object with position information for the first element in the selection, relative to its first positioned ancestor. This is a getter only.</li>
                                    <li><code>.val()</code> – Get or set the value of form elements.</li>
                                </ul>
                                
                                <p>Changing things about elements is trivial, but remember that the change will affect all elements in the selection. If you just want to change one element, be sure to specify that in the selection before calling a setter method.</p>
                                <pre><code>
                                // Changing the HTML of an element.
                                $( "#myDiv p:first" ).html( "New <strong>first</strong> paragraph!" );   
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Moving-Elements">Moving Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/#moving-copying-and-removing-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>While there are a variety of ways to move elements around the DOM, there are generally two approaches:</p>
                                
                                <ul>
                                    <li>Place the selected element(s) relative to another element.</li>
                                    <li>Place an element relative to the selected element(s).</li>
                                </ul>
                                
                                <p>For example, jQuery provides <code>.insertAfter()</code> and <code>.after()</code>. The <code>.insertAfter()</code> method places the selected element(s) after the element provided as an argument. The <code>.after()</code> method places the element provided as an argument after the selected element. Several other methods follow this pattern: <code>.insertBefore()</code> and <code>.before()</code>, <code>.appendTo()</code> and <code>.append()</code>, and <code>.prependTo()</code> and <code>.prepend()</code>.</p>
                                
                                <p>The method that makes the most sense will depend on what elements are selected, and whether you need to store a reference to the elements you're adding to the page. If you need to store a reference, you will always want to take the first approach – placing the selected elements relative to another element – as it returns the element(s) you're placing. In this case, <code>.insertAfter()</code>, <code>.insertBefore()</code>, <code>.appendTo()</code>, and <code>.prependTo()</code> should be the tools of choice.</p>
                                
                                <pre><code>
                                // Moving elements using different approaches.
 
                                // Make the first list item the last list item:
                                var li = $( "#myList li:first" ).appendTo( "#myList" );

                                // Another approach to the same problem:
                                $( "#myList" ).append( $( "#myList li:first" ) );

                                // Note that there's no way to access the list item
                                // that we moved, as this returns the list itself.
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Cloning-Elements">Cloning Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/#cloning-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Methods such as <code>.appendTo()</code> move the element, but sometimes a copy of the element is needed instead. In this case, use <code>.clone()</code> first:</p>
                                <pre><code>
                                // Making a copy of an element.
 
                                // Copy the first list item to the end of the list:
                                $( "#myList li:first" ).clone().appendTo( "#myList" );
                                </code></pre>
                                
                                <p>If you need to copy related data and events, be sure to pass <code>true</code> as an argument to <code>.clone()</code>.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Removing-Elements">Removing Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/#removing-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>There are two ways to remove elements from the page: <code>.remove()</code> and <code>.detach()</code>.</p>
                                
                                <ul>
                                    <li>Use <code>.remove()</code> when you want to permanently remove the selection from the page. While <code>.remove()</code> does return the removed element(s), those elements will not have their associated data and events attached to them if you return them to the page.</li>
                                    
                                    <li>Use <code>.detach()</code> if you need the data and events to persist. Like <code>.remove()</code>, it returns the selection, but it also maintains the data and events associated with the selection, so you can restore the selection to the page at a later time.</li> 
                                    
                                    <p>The <code>.detach()</code> method is extremely valuable if you are doing heavy manipulation on an element. In that case, it's beneficial to <code>.detach()</code> the element from the page, work on it in your code, then restore it to the page when you're done. This limits expensive "DOM touches" while maintaining the element's data and events.</p>
                                </ul>
                                
                                <p>If you want to leave the element on the page but remove its contents, you can use <code>.empty()</code> to dispose of the element's inner HTML.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Creating-New-Elements">Creating New Elements</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/#creating-new-elements">Source</a></span>
                            </h4>
                            <div class="content">
                                <ul>
                                    <li>jQuery offers a trivial and elegant way to create new elements using the same <code>$()</code> method used to make selections:</li>
                                    <pre><code>
                                    // Creating new elements from an HTML string.
                                    $( "&lt;p>This is a new paragraph&lt;/p>" );
                                    $( "&lt;li class=\"new\">new list item&lt;/li>" );

                                    // Creating a new element with an attribute object.
                                    $( "&lt;a/>", {
                                        html: "This is a &lt;strong>new&lt;/strong> link",
                                        "class": "new",
                                        href: "foo.html"
                                    });
                                    </code></pre>

                                    <p>Note that the attributes object in the second argument above, the property name <code>class</code> is quoted, although the property names <code>html</code> and <code>href</code> are not. Property names generally do not need to be quoted unless they are <a href="https://mathiasbynens.be/notes/reserved-keywords">reserved words</a> (as <code>class</code> is in this case).</p>
                                    
                                    <li>When you create a new element, it is not immediately added to the page. There are several ways to add an element to the page once it's been created.</li>
                                    <pre><code>
                                    // Getting a new element on to the page.
 
                                    var myNewElement = $( "&lt;p>New element&lt;/p>" );

                                    myNewElement.appendTo( "#content" );

                                    myNewElement.insertAfter( "ul:last" ); // This will remove the p from #content!

                                    $( "ul" ).last().after( myNewElement.clone() ); // Clone the p so now we have two.
                                    </code></pre>
                                    
                                    <li>The created element doesn't need to be stored in a variable – you can call the method to add the element to the page directly after the <code>$()</code>. However, most of the time you'll want a reference to the element you added so you won't have to select it later.</li>
                                    
                                    <li>You can also create an element as you're adding it to the page, but note that in this case you don't get a reference to the newly created element:</li>
                                    <pre><code>
                                    // Creating and adding an element to the page at the same time.
                                    $( "ul" ).append( "&lt;li>list item&lt;/li>" );
                                    </code></pre>
                                    
                                    <li>The syntax for adding new elements to the page is easy, so it's tempting to forget that there's a huge performance cost for adding to the DOM repeatedly. If you're adding many elements to the same container, you'll want to concatenate all the HTML into a single string, and then append that string to the container instead of appending the elements one at a time. Use an array to gather all the pieces together, then join them into a single string for appending:</li>
                                    <pre><code>
                                    var myItems = [];
                                    var myList = $( "#myList" );

                                    for ( var i = 0; i &lt; 100; i++ ) {
                                        myItems.push( "&lt;li>item " + i + "&lt;/li>" );
                                    }

                                    myList.append( myItems.join( "" ) );
                                    </code></pre>
                                </ul>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Manipulating-Attributes">Manipulating Attributes</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/manipulating-elements/#manipulating-attributes">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery's attribute manipulation capabilities are extensive. Basic changes are simple, but the <code>.attr()</code> method also allows for more complex manipulations. It can either set an explicit value, or set a value using the return value of a function. When the function syntax is used, the function receives two arguments: the zero-based index of the element whose attribute is being changed, and the current value of the attribute being changed.</p>
                                <pre><code>
                                // Manipulating a single attribute.
                                $( "#myDiv a:first" ).attr( "href", "newDestination.html" );
                                
                                // Manipulating multiple attributes.
                                $( "#myDiv a:first" ).attr({
                                    href: "newDestination.html",
                                    rel: "nofollow"
                                });
                                
                                // Using a function to determine an attribute's new value.
                                $( "#myDiv a:first" ).attr({
                                    rel: "nofollow",
                                    href: function( idx, href ) {
                                        return "/new/" + href;
                                    }
                                });

                                $( "#myDiv a:first" ).attr( "href", function( idx, href ) {
                                    return "/new/" + href;
                                });
                                </code></pre>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Traversing">Traversing</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/traversing/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>Traversing can be broken down into three basic parts: parents, children, and siblings.</p>
                            
                            <p>jQuery has an abundance of easy-to-use methods for all these parts. Notice that each of these methods can optionally be passed string selectors, and some can also take another jQuery object in order to filter your selection down. Pay attention and refer to the <a href="http://api.jquery.com/category/traversing/">API documentation on traversing</a> to know what variation of arguments you have available.</p>
                            
                            <h4 class="heading">
                                <span id="Parents">Parents</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/traversing/#parents">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The methods for finding the parents from a selection include <code>.parent()</code>, <code>.parents()</code>, <code>.parentsUntil()</code>, and <code>.closest()</code>.</p>
                                
                                <pre><code>
                                &lt;div class="grandparent">
                                    &lt;div class="parent">
                                        &lt;div class="child">
                                            &lt;span class="subchild">&lt;/span>
                                        &lt;/div>
                                    &lt;/div>
                                    &lt;div class="surrogateParent1">&lt;/div>
                                    &lt;div class="surrogateParent2">&lt;/div>
                                &lt;/div>
                            
                                // Selecting an element's direct parent:
 
                                // returns [ div.child ]
                                $( "span.subchild" ).parent();

                                // Selecting all the parents of an element that match a given selector:

                                // returns [ div.parent ]
                                $( "span.subchild" ).parents( "div.parent" );

                                // returns [ div.child, div.parent, div.grandparent ]
                                $( "span.subchild" ).parents();

                                // Selecting all the parents of an element up to, but *not including* the selector:

                                // returns [ div.child, div.parent ]
                                $( "span.subchild" ).parentsUntil( "div.grandparent" );

                                // Selecting the closest parent, note that only one parent will be selected
                                // and that the initial element itself is included in the search:

                                // returns [ div.child ]
                                $( "span.subchild" ).closest( "div" );

                                // returns [ div.child ] as the selector is also included in the search:
                                $( "div.child" ).closest( "div" );
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Children">Children</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/traversing/#children">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The methods for finding child elements from a selection include <code>.children()</code> and <code>.find()</code>. The difference between these methods lies in how far into the child structure the selection is made.</p>
                                
                                <ul>
                                    <li><code>.children()</code> only operates on direct child nodes, while</li>
                                    <li><code>.find()</code> can traverse recursively into children, children of those children, and so on.</li>
                                </ul>
                                
                                <pre><code>
                                // Selecting an element's direct children:
 
                                // returns [ div.parent, div.surrogateParent1, div.surrogateParent2 ]
                                $( "div.grandparent" ).children( "div" );

                                // Finding all elements within a selection that match the selector:

                                // returns [ div.child, div.parent, div.surrogateParent1, div.surrogateParent2 ]
                                $( "div.grandparent" ).find( "div" );
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Siblings">Siblings</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/traversing/#siblings">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The rest of the traversal methods within jQuery all deal with finding sibling selections. There are a few basic methods as far as the direction of traversal is concerned. You can find previous elements with <code>.prev()</code>, next elements with <code>.next()</code>, and both with <code>.siblings()</code>. There are also a few other methods that build onto these basic methods: <code>.nextAll()</code>, <code>.nextUntil()</code>, <code>.prevAll()</code> and <code>.prevUntil()</code>.</p>
                                
                                <pre><code>
                                // Selecting a next sibling of the selectors:
 
                                // returns [ div.surrogateParent1 ]
                                $( "div.parent" ).next();

                                // Selecting a prev sibling of the selectors:

                                // returns [] as No sibling exists before div.parent
                                $( "div.parent" ).prev();

                                // Selecting all the next siblings of the selector:

                                // returns [ div.surrogateParent1, div.surrogateParent2 ]
                                $( "div.parent" ).nextAll();

                                // returns [ div.surrogateParent1 ]
                                $( "div.parent" ).nextAll().first();

                                // returns [ div.surrogateParent2 ]
                                $( "div.parent" ).nextAll().last();

                                // Selecting all the previous siblings of the selector:

                                // returns [ div.surrogateParent1, div.parent ]
                                $( "div.surrogateParent2" ).prevAll();

                                // returns [ div.surrogateParent1 ]
                                $( "div.surrogateParent2" ).prevAll().first();

                                // returns [ div.parent ]
                                $( "div.surrogateParent2" ).prevAll().last();
                                </code></pre>
                                
                                <p>Use <code>.siblings()</code> to select all siblings:</p>
                                <pre><code>
                                // Selecting an element's siblings in both directions that matches the given selector:
 
                                // returns [ div.surrogateParent1, div.surrogateParent2 ]
                                $( "div.parent" ).siblings();

                                // returns [ div.parent, div.surrogateParent2 ]
                                $( "div.surrogateParent1" ).siblings();
                                </code></pre>
                            </div>
                            
                            <p>See the complete documentation for these methods and more at <a href="http://api.jquery.com/category/traversing/tree-traversal/">Traversal documentation on api.jquery.com</a>.</p>
                            
                            <p>Be cautious when traversing long distances in documents – complex traversal makes it imperative that the document's structure remain the same, which is difficult to guarantee even if you're the one creating the whole application from server to client. One- or two-step traversal is fine, but it's best to avoid traversals that go from one container to another.</p>
                        </div>
                        
                        <h3 class="heading">
                            <span id="CSS-Styling-Dimensions">CSS, Styling, & Dimensions</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/css-styling-dimensions/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="CSS">CSS</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/css-styling-dimensions/">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Query includes a handy way to get and set CSS properties of elements:</p>
                                <pre><code>
                                // Getting CSS properties.
 
                                $( "h1" ).css( "fontSize" ); // Returns a string such as "19px".

                                $( "h1" ).css( "font-size" ); // Also works.
                                
                                // Setting CSS properties.
 
                                $( "h1" ).css( "fontSize", "100px" ); // Setting an individual property.

                                // Setting multiple properties.
                                $( "h1" ).css({
                                    fontSize: "100px",
                                    color: "red"
                                });
                                </code></pre>
                                
                                <p>Note the style of the argument on the second line – it is an object that contains multiple properties. This is a common way to pass multiple arguments to a function, and many jQuery setter methods accept objects to set multiple values at once.</p>
                                
                                <p>CSS properties that normally include a hyphen need to be camelCased in JavaScript. For example, the CSS property <code>font-size</code> is expressed as <code>fontSize</code> when used as a property name in JavaScript. However, this does not apply when passing the name of a CSS property to the <code>.css()</code> method as a string – in that case, either the camelCased or hyphenated form will work.</p>
                                
                                <p>It's not recommended to use <code>.css()</code> as a setter in production-ready code, but when passing in an object to set CSS, CSS properties will be camelCased instead of using a hyphen.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Using-CSS-Classes-for-Styling">Using CSS Classes for Styling</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/css-styling-dimensions/#using-css-classes-for-styling">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>As a getter, the <code>.css()</code> method is valuable. However, it should generally be avoided as a setter in production-ready code, because it's generally best to keep presentational information out of JavaScript code. Instead, write CSS rules for classes that describe the various visual states, and then change the class on the element.</p>
                                <pre><code>
                                // Working with classes.
 
                                var h1 = $( "h1" );

                                h1.addClass( "big" );
                                h1.removeClass( "big" );
                                h1.toggleClass( "big" );

                                if ( h1.hasClass( "big" ) ) {
                                    ...
                                }
                                </code></pre>
                                
                                <p>Classes can also be useful for storing state information about an element, such as indicating that an element is selected.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Dimensions">Dimensions</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/css-styling-dimensions/#dimensions">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The code below shows a brief overview of the dimensions functionality in jQuery. For complete details about jQuery dimension methods, visit the <a href="http://api.jquery.com/category/dimensions/">dimensions documentation on api.jquery.com</a>.</p>
                                <pre><code>
                                // Basic dimensions methods.
 
                                // Sets the width of all &lt;h1> elements.
                                $( "h1" ).width( "50px" );

                                // Gets the width of the first &lt;h1> element.
                                $( "h1" ).width();

                                // Sets the height of all &lt;h1> elements.
                                $( "h1" ).height( "50px" );

                                // Gets the height of the first &lt;h1> element.
                                $( "h1" ).height();


                                // Returns an object containing position information for
                                // the first &lt;h1> relative to its "offset (positioned) parent".
                                $( "h1" ).position();
                                </code></pre>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Data-Methods">Data Methods</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/data-methods/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>There's often data about an element you want to store with the element. In plain JavaScript, you might do this by adding a property to the DOM element, but you'd have to deal with memory leaks in some browsers. jQuery offers a straightforward way to store data related to an element, and it manages the memory issues for you.</p>
                            <pre><code>
                            // Storing and retrieving data related to an element.
 
                            $( "#myDiv" ).data( "keyName", { foo: "bar" } );

                            $( "#myDiv" ).data( "keyName" ); // Returns { foo: "bar" }
                            </code></pre>
                            
                            <p>Any kind of data can be stored on an element. For the purposes of this article, <code>.data()</code> will be used to store references to other elements.</p>
                            
                            <ul>
                                <li>For example, you may want to establish a relationship between a list item and a <code>&lt;div></code> that's inside of it. This relationship could be established every single time the list item is touched, but a better solution would be to establish the relationship once, then store a pointer to the <code>&lt;div></code> on the list item using <code>.data()</code>:</li>
                                <pre><code>
                                // Storing a relationship between elements using .data()
 
                                $( "#myList li" ).each(function() {

                                    var li = $( this );
                                    var div = li.find( "div.content" );

                                    li.data( "contentDiv", div );

                                });

                                // Later, we don't have to find the div again;
                                // we can just read it from the list item's data
                                var firstLi = $( "#myList li:first" );

                                firstLi.data( "contentDiv" ).html( "new content" );
                                </code></pre>
                            </ul>
                            
                            <p>In addition to passing <code>.data()</code> a single key-value pair to store data, you can also pass an object containing one or more pairs.</p>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Utility-Methods">Utility Methods</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>jQuery offers several utility methods in the <code>$</code> namespace. These methods are helpful for accomplishing routine programming tasks. For a complete reference on jQuery utility methods, visit the <a href="http://api.jquery.com/category/utilities/">utilities documentation on api.jquery.com</a>.</p>
                            
                            <p>Below are examples of a few of the utility methods:</p>
                            
                            <h4 class="heading command">
                                <span id="trim"><code>$.trim()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/#trim-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Removes leading and trailing whitespace:</p>
                                
                                <pre><code>
                                // Returns "lots of extra whitespace"
                                $.trim( "    lots of extra whitespace    " );
                                </code></pre>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="utility-method-each"><code>$.each()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/#each-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Iterates over arrays and objects:</p>
                                <pre><code>
                                $.each([ "foo", "bar", "baz" ], function( idx, val ) {
                                    console.log( "element " + idx + " is " + val );
                                });

                                $.each({ foo: "bar", baz: "bim" }, function( k, v ) {
                                    console.log( k + " : " + v );
                                });
                                </code></pre>
                                
                                <p>The method <code>.each()</code> can be called on a selection to iterate over the elements contained in the selection. <code>.each()</code>, not <code>$.each()</code>, should be used for iterating over elements in a selection.</p>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="inArray"><code>$.inArray()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/#inarray-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Returns a value's index in an array, or -1 if the value is not in the array:</p>
                                <pre><code>
                                var myArray = [ 1, 2, 3, 5 ];
 
                                if ( $.inArray( 4, myArray ) !== -1 ) {
                                    console.log( "found it!" );
                                }
                                </code></pre>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="extend"><code>$.extend()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/#extend-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Changes the properties of the first object using the properties of subsequent objects:</p>
                                <pre><code>
                                var firstObject = { foo: "bar", a: "b" };
                                var secondObject = { foo: "baz" };

                                var newObject = $.extend( firstObject, secondObject );

                                console.log( firstObject.foo ); // "baz"
                                console.log( newObject.foo ); // "baz"
                                </code></pre>
                                
                                <p>If you don't want to change any of the objects you pass to <code>$.extend()</code>, pass an empty object as the first argument:</p>
                                <pre><code>
                                var firstObject = { foo: "bar", a: "b" };
                                var secondObject = { foo: "baz" };

                                var newObject = $.extend( {}, firstObject, secondObject );

                                console.log( firstObject.foo ); // "bar"
                                console.log( newObject.foo ); // "baz"
                                </code></pre>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="proxy"><code>$.proxy()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/#proxy-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Returns a function that will always run in the provided scope — that is, sets the meaning of <code>this</code> inside the passed function to the second argument.</p>
                                <pre><code>
                                var myFunction = function() {
                                    console.log( this );
                                };
                                var myObject = {
                                    foo: "bar"
                                };

                                myFunction(); // window

                                var myProxyFunction = $.proxy( myFunction, myObject );

                                myProxyFunction(); // myObject
                                </code></pre>
                                
                                <p>If you have an object with methods, you can pass the object and the name of a method to return a function that will always run in the scope of the object.</p>
                                <pre><code>
                                var myObject = {
                                    myFn: function() {
                                        console.log( this );
                                    }
                                };

                                $( "#foo" ).click( myObject.myFn ); // HTMLElement #foo
                                $( "#foo" ).click( $.proxy( myObject, "myFn" ) ); // myObject
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Testing-Type">Testing Type</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/utility-methods/#testing-type">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Sometimes the <code>typeof</code> operator <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">can be confusing or inconsistent</a>, so instead of using <code>typeof</code>, jQuery offers utility methods to help determine the type of a value.</p>
                                <ul>
                                    <li>First of all, you have methods to test if a specific value is of a specific type.</li>
                                    <pre><code>
                                    $.isArray([]); // true
                                    $.isFunction(function() {}); // true
                                    $.isNumeric(3.14); // true
                                    </code></pre>

                                    <li>Additionally, there is <code>$.type()</code> which checks for the internal class used to create a value. You can see the method as a better alternative for the <code>typeof</code> operator.</li>
                                    <pre><code>
                                    $.type( true ); // "boolean"
                                    $.type( 3 ); // "number"
                                    $.type( "test" ); // "string"
                                    $.type( function() {} ); // "function"

                                    $.type( new Boolean() ); // "boolean"
                                    $.type( new Number(3) ); // "number"
                                    $.type( new String('test') ); // "string"
                                    $.type( new Function() ); // "function"

                                    $.type( [] ); // "array"
                                    $.type( null ); // "null"
                                    $.type( /test/ ); // "regexp"
                                    $.type( new Date() ); // "date"
                                    </code></pre>
                                    <p>As always, you can check the <a href="http://api.jquery.com/jQuery.type/">API docs</a> for a more in-depth explanation.</p>
                                </ul>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Iterating-over-jQuery-and-non-jQuery-Objects">Iterating over jQuery and non-jQuery Objects</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>jQuery provides an object iterator utility called <code>$.each()</code> as well as a jQuery collection iterator: <code>.each()</code>. These are not interchangeable. In addition, there are a couple of helpful methods called <code>$.map()</code> and <code>.map()</code> that can shortcut one of our common iteration use cases.</p>
                            
                            <h4 class="heading command">
                                <span id="each"><code>$.each()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/#each-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p><code>$.each()</code> is a generic iterator function for looping over object, arrays, and array-like objects. Plain objects are iterated via their named properties while arrays and array-like objects are iterated via their indices.</p>
                                
                                <p><code>$.each()</code> is essentially a drop-in replacement of a traditional for or for-in loop.</p>
                                <ul>
                                    <li>Given:</li>
                                    <pre><code>
                                    var sum = 0;

                                    var arr = [ 1, 2, 3, 4, 5 ];

                                    for ( var i = 0, l = arr.length; i &lt; l; i++ ) {
                                        sum += arr[ i ];
                                    }

                                    console.log( sum ); // 15
                                    </code></pre>

                                    <p>Can be replaced with this:</p>
                                    <pre><code>
                                    $.each( arr, function( index, value ){
                                        sum += value;
                                    });

                                    console.log( sum ); // 15
                                    </code></pre>

                                    <p>Notice that we don't have to access <code>arr[ index ]</code> as the value is conveniently passed to the callback in <code>$.each()</code></p>
                                    
                                    <li>In addition, given:</li>
                                    <pre><code>
                                    var sum = 0;
                                    var obj = {
                                        foo: 1,
                                        bar: 2
                                    }
                                    
                                    for (var item in obj) {
                                        sum += obj[ item ];
                                    }

                                    console.log( sum ); // 3
                                    </code></pre>
                                    
                                    <p>Can be replaced with this:</p>
                                    <pre><code>
                                    $.each( obj, function( key, value ) {
                                        sum += value;
                                    });

                                    console.log( sum ); // 3
                                    </code></pre>
                                    
                                    <p>Again, we don't have to directly access <code>obj[ key ]</code> as the value is passed directly to the callback.</p>
                                </ul>
                                
                                <p>Note that <code>$.each()</code> is for plain objects, arrays, array-like objects that are not jQuery collections.</p>
                                
                                <p>This would be considered incorrect:</p>
                                <pre><code>
                                // Incorrect:
                                $.each( $( "p" ), function() {
                                    // Do something
                                });
                                </code></pre>
                                
                                <p>For jQuery collections, use <code>.each()</code>.</p>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="each-"><code>.each()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/#each-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p><code>.each()</code> is used directly on a jQuery collection. It iterates over each matched element in the collection and performs a callback on that object. The index of the current element within the collection is passed as an argument to the callback. The value (the DOM element in this case) is also passed, but the callback is fired within the context of the current matched element so the <code>this</code> keyword points to the current element as expected in other jQuery callbacks.</p>
                                
                                <p>For example, given the following markup:</p>
                                <pre><code>
                                &lt;ul>
                                    &lt;li>&lt;a href="#">Link 1&lt;/a>&lt;/li>
                                    &lt;li>&lt;a href="#">Link 2&lt;/a>&lt;/li>
                                    &lt;li>&lt;a href="#">Link 3&lt;/a>&lt;/li>
                                &lt;/ul>
                                </code></pre>
                                
                                <p><code>.each()</code> may be used like so:</p>
                                <pre><code>
                                $( "li" ).each( function( index, element ){
                                    console.log( $( this ).text() );
                                });

                                // Logs the following:
                                // Link 1
                                // Link 2
                                // Link 3
                                </code></pre>
                                
                                <h5 class="heading aftercommand">
                                    <span id="The-Second-Argument">The Second Argument</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/#the-second-argument">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>The question is often raised, "If <code>this</code> is the element, why is there a second DOM element argument passed to the callback?"</p>
                                    
                                    <p>Whether intentional or inadvertent, the execution context may change. When consistently using the keyword <code>this</code>, it's easy to end up confusing ourselves or other developers reading the code. Even if the execution context remains the same, it may be more readable to use the second parameter as a named parameter. For example:</p>
                                    <pre><code>
                                    $( "li" ).each( function( index, listItem ) {
 
                                        this === listItem; // true

                                        // For example only. You probably shouldn't call $.ajax() in a loop.
                                        $.ajax({
                                            success: function( data ) {
                                                // The context has changed.
                                                // The "this" keyword no longer refers to listItem.
                                                this !== listItem; // true
                                            }
                                        });

                                    });
                                    </code></pre>
                                </div>
                                
                                <h5 class="heading aftercommand">
                                    <span id="Sometimes-each-Isnt-Necessary">Sometimes .each() Isn't Necessary</span>
                                    <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/#sometimes-each-isn-39-t-necessary">Source</a></span>
                                </h5>
                                <div class="content">
                                    <ul>
                                        <li>Many jQuery methods implicitly iterate over the entire collection, applying their behavior to each matched element. For example, this is unnecessary:</li>
                                        <pre><code>
                                        $( "li" ).each( function( index, el ) {
                                            $( el ).addClass( "newClass" );
                                        });
                                        </code></pre>

                                        <p>And this is fine:</p>
                                        <pre><code>
                                        $( "li" ).addClass( "newClass" );
                                        </code></pre>

                                        <p>Each <code>&lt;li></code>code> in the document will have the class "newClass" added.</p>
                                        
                                        <li>On the other hand, some methods do not iterate over the collection. <code>.each()</code> is required when we need to get information from the element before setting a new value.</li>
                                        
                                        <p>This will not work:</p>
                                        <pre><code>
                                        // Doesn't work:
                                        $( "input" ).val( $( this ).val() + "%" );

                                        // .val() does not change the execution context, so this === window
                                        </code></pre>
                                        
                                        <p>Rather, this is how it should be written:</p>
                                        <pre><code>
                                        $( "input" ).each( function( i, el ) {
                                            var elem = $( el );
                                            elem.val( elem.val() + "%" );
                                        });
                                        </code></pre>
                                        
                                        <p>The following is a list of methods that require <code>.each()</code>:</p>
                                        <ul>
                                            <li><code>.attr()</code> (getter)</li>
                                            <li><code>.css()</code> (getter)</li>
                                            <li><code>.data()</code> (getter)</li>
                                            <li><code>.height()</code> (getter)</li>
                                            <li><code>.html()</code> (getter)</li>
                                            <li><code>.innerHeight()</code></li>
                                            <li><code>.innerWidth()</code></li>
                                            <li><code>.offset()</code> (getter)</li>
                                            <li><code>.outerHeight()</code></li>
                                            <li><code>.outerWidth()</code></li>
                                            <li><code>.position()</code></li>
                                            <li><code>.prop()</code> (getter)</li>
                                            <li><code>.scrollLeft()</code> (getter)</li>
                                            <li><code>.scrollTop()</code> (getter)</li>
                                            <li><code>.val()</code> (getter)</li>
                                            <li><code>.width()</code> (getter)</li>
                                        </ul>
                                        
                                        <p>Note that in most cases, the "getter" signature returns the result from the first element in a jQuery collection while the setter acts over the entire collection of matched elements. The exception to this is <code>.text()</code> where the getter signature will return a concatenated string of text from all matched elements.</p>
                                        
                                        <p>In addition to a setter value, the attribute, property, CSS setters, and DOM insertion "setter" methods (i.e. <code>.text()</code> and <code>.html()</code>) accept anonymous callback functions that are applied to each element in the matching set. The arguments passed to the callback are the index of the matched element within the set and the result of the 'getter' signature of the method.</p>
                                        
                                        <p>For example, these are equivalent:</p>
                                        <pre><code>
                                        $( "input" ).each( function( i, el ) {
                                            var elem = $( el );
                                            elem.val( elem.val() + "%" );
                                        });

                                        $( "input" ).val(function( index, value ) {
                                            return value + "%";
                                        });
                                        </code></pre>
                                        
                                        <p>One other thing to keep in mind with this implicit iteration is that traversal methods such as <code>.children()</code> or <code>.parent()</code> will act on each matched element in a collection, returning a combined collection of all children or parent nodes.</p>
                                    </ul>
                                </div>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="map"><code>.map()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/#map-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>There is a common iteration use case that can be better handled by using the <code>.map()</code> method. Anytime we want to create an array or concatenated string based on all matched elements in our jQuery selector, we're better served using <code>.map()</code></p>
                                
                                <p>For example instead of doing this:</p>
                                <pre><code>
                                var newArr = [];
 
                                $( "li" ).each( function() {
                                    newArr.push( this.id );
                                });
                                </code></pre>
                                
                                <p>We can do this:</p>
                                <pre><code>
                                $( "li" ).map( function(index, element) {
                                    return this.id;
                                }).get();
                                </code></pre>
                                
                                <p>Notice the <code>.get()</code> chained at the end. <code>.map()</code> actually returns a jQuery-wrapped collection, even if we return strings out of the callback. We need to use the argument-less version of <code>.get()</code> in order to return a basic JavaScript array that we can work with. To concatenate into a string, we can chain the plain JS <code>.join()</code> array method after <code>.get()</code>.</p>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="map-"><code>$.map</code></span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/iterating/#map">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Like <code>$.each()</code> and <code>.each()</code>, there is a <code>$.map()</code> as well as <code>.map()</code>. The difference is also very similar to both <code>.each()</code> methods. <code>$.map()</code> works on plain JavaScript arrays while <code>.map()</code> works on jQuery element collections. Because it's working on a plain array, <code>$.map()</code> returns a plain array and <code>.get()</code> does not need to be called – in fact, it will throw an error as it's not a native JavaScript method.</p>
                                
                                <p>A word of warning: <code>$.map()</code> switches the order of callback arguments. This was done in order to match the native JavaScript <code>.map()</code> method made available in ECMAScript 5.</p>
                                
                                <p>For example:</p>
                                <pre><code>
                                &lt;li id="a">&lt;/li>
                                &lt;li id="b">&lt;/li>
                                &lt;li id="c">&lt;/li>

                                &lt;script>

                                var arr = [{
                                    id: "a",
                                    tagName: "li"
                                }, {
                                    id: "b",
                                    tagName: "li"
                                }, {
                                    id: "c",
                                    tagName: "li"
                                }];

                                // Returns [ "a", "b", "c" ]
                                $( "li" ).map( function( index, element ) {
                                    return element.id;
                                }).get();

                                // Also returns [ "a", "b", "c" ]
                                // Note that the value comes first with $.map
                                $.map( arr, function( value, index ) {
                                    return value.id;
                                });

                                &lt;/script>
                                </code></pre>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Using-jQuerys-index-Function">Using jQuery’s <code>.index()</code> Function</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/understanding-index/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p><code>.index()</code> is a method on jQuery objects that's generally used to search for a given element within the jQuery object that it's called on. This method has four different signatures with different semantics that can be confusing. This article covers details about how to understand the way <code>.index()</code> works with each signature.</p>
                            
                            <h4 class="heading command">
                                <span id="index-with-No-Arguments"><code>.index()</code> with No Arguments</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/understanding-index/#index-with-no-arguments">Source</a></span>
                            </h4>
                            <div class="content">
                                <pre><code>
                                &lt;ul>
                                    &lt;div>&lt;/div>
                                    &lt;li id="foo1">foo&lt;/li>
                                    &lt;li id="bar1">bar&lt;/li>
                                    &lt;li id="baz1">baz&lt;/li>
                                    &lt;div>&lt;/div>
                                &lt;/ul>
                                
                                var foo = $( "#foo1" );
 
                                console.log( "Index: " + foo.index() ); // 1

                                var listItem = $( "li" );

                                // This implicitly calls .first()
                                console.log( "Index: " + listItem.index() ); // 1
                                console.log( "Index: " + listItem.first().index() ); // 1

                                var div = $( "div" );

                                // This implicitly calls .first()
                                console.log( "Index: " + div.index() ); // 0
                                console.log( "Index: " + div.first().index() ); // 0
                                </code></pre>
                                
                                <p>In the first example, <code>.index()</code> gives the zero-based index of <code>#foo1</code> within its parent. Since <code>#foo1</code> is the second child of its parent, <code>index()</code> returns 1.</p>
                                
                                <p>Note: Before jQuery 1.9, <code>.index()</code> only worked reliably on a single element, which is why we've used <code>.first()</code> on each of our examples. In jQuery 1.9+ this can be ignored, as the API was updated to define that it operates on the first element only.</p>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="index-with-a-String-Argument"><code>.index()</code> with a String Argument</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/understanding-index/#index-with-a-string-argument">Source</a></span>
                            </h4>
                            <div class="content">
                                <pre><code>
                                &lt;ul>
                                    &lt;div class="test">&lt;/div>
                                    &lt;li id="foo1">foo&lt;/li>
                                    &lt;li id="bar1" class="test">bar&lt;/li>
                                    &lt;li id="baz1">baz&lt;/li>
                                    &lt;div class="test">&lt;/div>
                                &lt;/ul>
                                &lt;div id="last">&lt;/div>
                                
                                var foo = $( "li" );
 
                                // This implicitly calls .first()
                                console.log( "Index: " + foo.index( "li" ) ); // 0
                                console.log( "Index: " + foo.first().index( "li" ) ); // 0

                                var baz = $( "#baz1" );
                                console.log( "Index: " + baz.index( "li" )); // 2

                                var listItem = $( "#bar1" );
                                console.log( "Index: " + listItem.index( ".test" ) ); // 1

                                var div = $( "#last" );
                                console.log( "Index: " + div.index( "div" ) ); // 2
                                </code></pre>
                                
                                <p>When <code>.index()</code> is called with a string argument, there are two things to consider.</p>
                                
                                <ul>
                                    <li>First, jQuery will implicitly call <code>.first()</code> on the original jQuery object. It will find the index of the first element, not the last element in this case. This is inconsistent, so be careful here.</li>
                                    
                                    <li>The second point to consider is that jQuery is querying the entire DOM using the passed in string selector and checking the index within that newly queried jQuery object. For example, when using <code>.index( "div" )</code> in the last example above, jQuery is selecting all of the <code>&lt;div></code> elements in the document, then searching for the index that contains the first element in the jQuery object <code>.index()</code> is called on.</li>
                                </ul>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="index-with-a-jQuery-Object-Argument"><code>.index()</code> with a jQuery Object Argument</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/understanding-index/#index-with-a-jquery-object-argument">Source</a></span>
                            </h4>
                            <div class="content">
                                <pre><code>
                                &lt;ul>
                                    &lt;div class="test">&lt;/div>
                                    &lt;li id="foo1">foo&lt;/li>
                                    &lt;li id="bar1" class="test">bar&lt;/li>
                                    &lt;li id="baz1">baz&lt;/li>
                                    &lt;div class="test">&lt;/div>
                                &lt;/ul>
                                &lt;div id="last">&lt;/div>
                                
                                var foo = $( "li" );
                                var baz = $( "#baz1" );

                                console.log( "Index: " + foo.index( baz ) ); // 2

                                var tests = $( ".test" );
                                var bar = $( "#bar1" );

                                // Implicitly calls .first() on the argument.
                                console.log( "Index: " + tests.index( bar ) ); // 1

                                console.log( "Index: " + tests.index( bar.first() ) ); // 1
                                </code></pre>
                                
                                <p>In this case, the first element of the jQuery object that is passed into <code>.index()</code> is being checked against all of the elements in the original jQuery object. The original jQuery object, on the left side of <code>.index()</code>, is array-like and is searched from index 0 through <code>length - 1</code> for the first element of the argument jQuery object.</p>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="index-with-a-DOM-Element-Argument"><code>.index()</code> with a DOM Element Argument</span>
                                <span class="source"><a href="https://learn.jquery.com/using-jquery-core/understanding-index/#index-with-a-dom-element-argument">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>In this case, the DOM element that's passed into <code>.index()</code> is being checked against all of the elements in the original jQuery object. Once all other cases are understood, this should be the simplest case. It is very similar to the previous case, except since the DOM element is passed directly, it is not taken from a jQuery object container.</p>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Frequently-Asked-Questions">Frequently Asked Questions</span>
                            <span class="source"><a href="https://learn.jquery.com/using-jquery-core/faq/">Source</a></span>
                        </h3>
                        <div class="content">
                            <ul>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-item-using-class-or-id/">How do I select an item using class or ID?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-select-elements-when-i-already-have-a-dom-element/">How do I select elements when I already have a DOM element?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-test-whether-an-element-has-a-particular-class/">How do I test whether an element has a particular class?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-test-whether-an-element-exists/">How do I test whether an element exists?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-determine-the-state-of-a-toggled-element/">How do I determine the state of a toggled element?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/">How do I select an element by an ID that has characters used in CSS notation?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-disable-enable-a-form-element/">How do I disable/enable a form element?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-check-uncheck-a-checkbox-input-or-radio-button/">How do I check/uncheck a checkbox input or radio button?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-get-the-text-value-of-a-selected-option/">How do I get the text value of a selected option?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-replace-text-from-the-3rd-element-of-a-list-of-10-items/">How do I replace text from the 3rd element of a list of 10 items?</a></li>
                                <li><a href="https://learn.jquery.com/using-jquery-core/faq/how-do-i-pull-a-native-dom-element-from-a-jquery-object/">How do I pull a native DOM element from a jQuery object?</a></li>
                            </ul>
                        </div>
                    </div>
                    
                    <h2 class="heading">
                        <span id="Events">Events</span>
                        <span class="source"><a href="https://learn.jquery.com/events/">Source</a></span>
                    </h2>
                    <div class="content">
                        <p>jQuery provides simple methods for attaching event handlers to selections. When an event occurs, the provided function is executed. Inside the function, <code>this</code> refers to the DOM element that initiated the event.</p>

                        <p>For details on jQuery events, visit the <a href="http://api.jquery.com/category/events/">Events documentation on api.jquery.com</a>.</p>

                        <p>The event handling function can receive an event object. This object can be used to determine the nature of the event, and to prevent the event’s default behavior. For details on the event object, visit the <a href="http://api.jquery.com/category/events/event-object/">Event object documentation on api.jquery.com</a>.</p>
                        
                        <h3 class="heading">
                            <span id="Introducing-Events">Introducing Events</span>
                            <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="Introduction">Introduction</span>
                                <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#introduction">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Web pages are all about interaction. Users perform a countless number of actions such as moving their mice over the page, clicking on elements, and typing in textboxes — all of these are examples of events. In addition to these user events, there are a slew of others that occur, like when the page is loaded, when video begins playing or is paused, etc. Whenever something interesting occurs on the page, an event is fired, meaning that the browser basically announces that something has happened. It's this announcement that allows developers to "listen" for events and react to them appropriately.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="What-s-a-DOM-event">What's a DOM event?</span>
                                <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#what-39-s-a-dom-event">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>As mentioned, there are a myriad of event types, but perhaps the ones that are easiest to understand are user events, like when someone clicks on an element or types into a form. These types of events occur on an element, meaning that when a user clicks on a button for example, the button has had an event occur on it. While user interactions aren't the only types of DOM events, they're certainly the easiest to understand when starting out. Mozilla Developer Network has a good reference of <a href="https://developer.mozilla.org/en-US/docs/Web/Events">available DOM events</a>.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Ways-to-listen-for-events">Ways to listen for events</span>
                                <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#ways-to-listen-for-events">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>There are many ways to listen for events. Actions are constantly occurring on a webpage, but the developer is only notified about them if they're listening for them. Listening for an event basically means you're waiting for the browser to tell you that a specific event has occurred and then you'll specify how the page should react.</p>

                                <p>To specify to the browser what to do when an event occurs, you provide a function, also known as an event handler. This function is executed whenever the event occurs (or until the event is unbound).</p>
                                
                                <ul>
                                    <li><em>Obtrusive JavaScript:</em></li>
                                    
                                    <p>For instance, to alert a message whenever a user clicks on a button, you might write something like this:</p>

                                    <pre><code>
                                    &lt;button onclick="alert('Hello')">Say hello&lt;/button>
                                    </code></pre>
                                    
                                    <p>The event we want to listen to is specified by the button's <code>onclick</code> attribute, and the event handler is the <code>alert</code> function which alerts "Hello" to the user. While this works, it's an abysmal way to achieve this functionality for a couple of reasons:</p>
                                    <ul>
                                        <li>First, we're coupling our view code (HTML) with our interaction code (JS). That means that whenever we need to update functionality, we'd have to edit our HTML which is just a bad practice and a maintenance nightmare.</li>
                                        <li>Second, it's not scalable. If you had to attach this functionality onto numerous buttons, you'd not only bloat the page with a bunch of repetitious code, but you would again destroy maintainability.</li>
                                    </ul>
                                    
                                    <li><em>Unobtrusive JavaScript:</em></li>
                                    
                                    <p>Utilizing inline event handlers like this can be considered obtrusive JavaScript, but its opposite, unobtrusive JavaScript is a much more common way of discussing the topic.</p>
                                    
                                    <p>The notion of unobtrusive JavaScript is that your HTML and JS are kept separate and are therefore more maintainable. Separation of concerns is important because it keeps like pieces of code together (i.e. HTML, JS, CSS) and unlike pieces of code apart, facilitating changes, enhancements, etc. Furthermore, unobtrusive JavaScript stresses the importance of adding the least amount of cruft to a page as possible. If a user's browser doesn't support JavaScript, then it shouldn't be intertwined into the markup of the page. Also, to prevent naming collisions, JS code should utilize a single namespace for different pieces of functionality or libraries. jQuery is a good example of this, in that the jQuery object/constructor (and also the <code>$</code> alias to jQuery) only utilizes a single global variable, and all of jQuery's functionality is packaged into that one object.</p>
                                    
                                    <p>To accomplish the desired task unobtrusively, let's change our HTML a little bit by removing the <code>onclick</code> attribute and replacing it with an <code>id</code>, which we'll utilize to "hook onto" the button from within a script file.</p>
                                    <pre><code>
                                    <button id="helloBtn">Say hello</button>
                                    </code></pre>
                                    
                                    <p>If we wanted to be informed when a user clicks on that button unobtrusively, we might do something like the following in a separate script file:</p>
                                    <pre><code>
                                    // Event binding using addEventListener
                                    var helloBtn = document.getElementById( "helloBtn" );

                                    helloBtn.addEventListener( "click", function( event ) {
                                        alert( "Hello." );
                                    }, false );
                                    </code></pre>
                                    
                                    <p>Here we're saving a reference to the button element by calling <code>getElementById</code> and assigning its return value to a variable. We then call <code>addEventListener</code> and provide an event handler function that will be called whenever that event occurs.</p> 
                                    
                                    <p>While there's nothing wrong with this code as it will work fine in modern browsers, it won't fare well in versions of IE prior to IE9. This is because Microsoft chose to implement a different method, <code>attachEvent</code>, as opposed to the W3C standard <code>addEventListener</code>, and didn't get around to changing it until IE9 was released. For this reason, it's beneficial to utilize jQuery because it abstracts away browser inconsistencies, allowing developers to use a single API for these types of tasks, as seen below.</p>
                                    <pre><code>
                                    // Event binding using a convenience method
                                    $( "#helloBtn" ).click(function( event ) {
                                        alert( "Hello." );
                                    });
                                    </code></pre>
                                    
                                    <p>The <code>$( "#helloBtn" )</code> code selects the button element using the <code>$</code> (a.k.a. jQuery) function and returns a jQuery object. The jQuery object has a bunch of methods (functions) available to it, one of them named <code>click</code>, which resides in the jQuery object's prototype. We call the <code>click</code> method on the jQuery object and pass along an anonymous function event handler that's going to be executed when a user clicks the button, alerting "Hello." to the user.</p>
                                </ul>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Setting-Up-Event-Responses-on-DOM-Elements">Setting Up Event Responses on DOM Elements</span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#setting-up-event-responses-on-dom-elements">Source 1</a></span>
                            <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#ways-to-listen-for-events">Source 2</a></span>
                        </h3>
                        <div class="content">
                            <p>There are a number of ways that events can be listened for using jQuery:</p>
                            <pre><code>
                            // The many ways to bind events with jQuery
                            // Attach an event handler directly to the button using jQuery's
                            // shorthand `click` method.
                            $( "#helloBtn" ).click(function( event ) {
                                alert( "Hello." );
                            });

                            // Attach an event handler directly to the button using jQuery's
                            // `bind` method, passing it an event string of `click`
                            $( "#helloBtn" ).bind( "click", function( event ) {
                                alert( "Hello." );
                            });

                            // As of jQuery 1.7, attach an event handler directly to the button
                            // using jQuery's `on` method.
                            $( "#helloBtn" ).on( "click", function( event ) {
                                alert( "Hello." );
                            });

                            // As of jQuery 1.7, attach an event handler to the `body` element that
                            // is listening for clicks, and will respond whenever *any* button is
                            // clicked on the page.
                            $( "body" ).on({
                                click: function( event ) {
                                    alert( "Hello." );
                                }
                            }, "button" );

                            // An alternative to the previous example, using slightly different syntax.
                            $( "body" ).on( "click", "button", function( event ) {
                                alert( "Hello." );
                            });
                            </code></pre>

                            <p>jQuery offers convenience methods for most native browser events. These methods — including <code>.click()</code>, <code>.focus()</code>, <code>.blur()</code>, <code>.change()</code>, etc. — are shorthand for jQuery's <code>.on()</code> method. The <code>on</code> method is useful for binding the same handler function to multiple events, when you want to provide data to the event handler, when you are working with custom events, or when you want to pass an object of multiple events and handlers.</p>

                            <p>As of jQuery 1.7, all events are bound via the <code>on</code> method, whether you call it directly or whether you use an alias/shortcut method such as <code>bind</code> or <code>click</code>, which are mapped to the <code>on</code> method internally. With this in mind, it's beneficial to use the <code>on</code> method because the others are all just syntactic sugar, and utilizing the <code>on</code> method is going to result in faster and more consistent code.</p>

                            <p>Let's look at the on examples from above and discuss their differences.</p>
                            <ul>
                                <li>In the first example, a string of <code>click</code> is passed as the first argument to the <code>on</code> method, and an anonymous function is passed as the second. This looks a lot like the <code>bind</code> method before it. Here, we're attaching an event handler directly to <code>#helloBtn</code>. If there were any other buttons on the page, they wouldn't alert "Hello" when clicked because the event is only attached to <code>#helloBtn</code>.</li>

                                <li>In the second on example, we're passing an object (denoted by the curly braces <code>{}</code>), which has a property of <code>click</code> whose value is an anonymous function. The second argument to the on method is a jQuery selector string of <code>button</code>. While examples 1–3 are functionally equivalent, example 4 is different in that the <code>body</code> element is listening for click events that occur on any <code>button</code> element, not just <code>#helloBtn</code>.</li> 

                                <li>The final example above is exactly the same as the one preceding it, but instead of passing an object, we pass an event string, a selector string, and the callback.</li> 

                                <p>Both of these are examples of event delegation, a process by which an element higher in the DOM tree listens for events occurring on its children.</p>
                            </ul>
                            
                            <h4 class="heading">
                                <span id="on">Event binding - <code>.on()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/events/handling-events/">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery provides a method <code>.on()</code> to respond to any event on the selected elements. This is called an event binding. Although <code>.on()</code> isn't the only method provided for event binding, it is a best practice to use this for jQuery 1.7+. To learn more, <a href="https://learn.jquery.com/events/history-of-events/">read more about the evolution of event binding in jQuery</a>.</p>

                                <p>The <code>.on()</code> method provides several useful features:</p>

                                <ul>
                                    <li><em>Simple event binding:</em> Bind any event triggered on the selected elements to an event handler</li>
                                    <pre><code>
                                    // When any &lt;p> tag is clicked, we expect to see '&lt;p> was clicked' in the console.
                                    $( "p" ).on( "click", function() {
                                        console.log( "&lt;p> was clicked" );
                                    });
                                    </code></pre>

                                    <li><em>Many events, but only one event handler:</em> Bind multiple events to one event handler</li>

                                    <p>Suppose you want to trigger the same event whenever the mouse hovers over or leaves the selected elements. The best practice for this is to use <code>"mouseenter mouseleave"</code>. Note the difference between this and the next example.</p>
                                    <pre><code>
                                    // When a user focuses on or changes any input element,
                                    // we expect a console message bind to multiple events
                                    $( "div" ).on( "mouseenter mouseleave", function() {
                                        console.log( "mouse hovered over or left a div" );
                                    });
                                    </code></pre>

                                    <li><em>Many events and handlers:</em> Bind multiple events and multiple handlers to the selected elements</li>

                                    <p>Suppose that instead you want different event handlers for when the mouse enters and leaves an element. This is more common than the previous example. For example, if you want to show and hide a tooltip on hover, you would use this. <code>.on()</code> accepts an object containing multiple events and handlers.</p>
                                    <pre><code>
                                    $( "div" ).on({
                                        mouseenter: function() {
                                            console.log( "hovered over a div" );
                                        },
                                        mouseleave: function() {
                                            console.log( "mouse left a div" );
                                        },
                                        click: function() {
                                            console.log( "clicked on a div" );
                                        }
                                    });
                                    </code></pre>

                                    <li><em>The event object:</em> Use details about the event in the event handler</li>

                                    <p>Handling events can be tricky. It's often helpful to use the extra information contained in the event object passed to the event handler for more control. To become familiar with the event object, use this code to inspect it in your browser console after you click on a <code>&lt;div></code> in the page. For a breakdown of the event object, see <a href="https://learn.jquery.com/events/inside-event-handling-function/">Inside the Event Handling Function</a>.</p>
                                    <pre><code>
                                    $( "div" ).on( "click", function( event ) {
                                        console.log( "event object:" );
                                        console.dir( event );
                                    });
                                    </code></pre>

                                    <li><em>Passing data to the event handler:</em> Pass data to the event handler for custom events</li>

                                    <p>You can pass your own data to the event object.</p>
                                    <pre><code>
                                    $( "p" ).on( "click", {
                                        foo: "bar"
                                    }, function( event ) {
                                        console.log( "event data: " + event.data.foo + " (should be 'bar')" );
                                    });
                                    </code></pre>

                                    <li><em>Binding events to elements that don't exist yet:</em> Bind events to elements that will be rendered in the future</li>

                                    <p>This is called event delegation. Here's an example just for completeness, but see the page on <a href="https://learn.jquery.com/events/event-delegation/">Event Delegation</a> for a full explanation.</p>
                                    <pre><code>
                                    $( "ul" ).on( "click", "li", function() {
                                        console.log( "Something in a &lt;ul> was clicked, and we detected that it was an &lt;li> element." );
                                    });
                                    </code></pre>
                                </ul>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Event-Helpers">Event Helpers</span>
                                <span class="source"><a href="https://learn.jquery.com/events/event-helpers/">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery offers a few event-related helper functions that save you a few keystrokes. Here is an example of one, the <code>.hover()</code> function.</p>

                                <h5 class="heading command">
                                    <span id="hover"><code>.hover()</code></span>
                                    <span class="source"><a href="https://learn.jquery.com/events/event-helpers/#hover-">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>The .hover() method lets you pass one or two functions to be run when the mouseenter and mouseleave events occur on an element. If you pass one function, it will be run for both events; if you pass two functions, the first will run for mouseenter, and the second will run for mouseleave.</p>

                                    <p>Note: Prior to jQuery 1.4, the .hover() method required two functions.</p>

                                    <pre><code>
                                    // The hover helper function
                                    $( "#menu li" ).hover(function() {
                                        $( this ).toggleClass( "hover" );
                                    });
                                    </code></pre>
                                </div>

                                <p>You can find more helper functions on the <a href="https://api.jquery.com/category/events/">API site for Events</a>.</p>
                            </div>
                        </div>
                                            
                        <h3 class="heading">
                            <span id="Extending-Events-to-New-Page-Elements">Extending Events to New Page Elements</span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#extending-events-to-new-page-elements">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>It is important to note that <code>.on()</code> can only create event listeners on elements that exist at the time you set up the listeners. Similar elements created after the event listeners are established will not automatically pick up event behaviors you've set up previously. For example:</p>
                            <pre><code>
                            $( document ).ready(function(){

                                // Sets up click behavior on all button elements with the alert class
                                // that exist in the DOM when the instruction was executed
                                $( "button.alert" ).on( "click", function() {
                                    console.log( "A button with the alert class was clicked!" );
                                });

                                // Now create a new button element with the alert class. This button
                                // was created after the click listeners were applied above, so it
                                // will not have the same click behavior as its peers
                                $( "&lt;button class='alert'>Alert!&lt;/button>" ).appendTo( document.body );
                            });
                            </code></pre>
                            <p>Consult the article on event delegation to see how to use <code>.on()</code> so that event behaviors will be extended to new elements without having to rebind them.</p>
                        </div>

                        <h3 class="heading">
                            <span id="Event-delegation">Event delegation</span>
                            <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#event-delegation">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>Event delegation works because of the notion of event bubbling. For most events, whenever something occurs on a page (like an element is clicked), the event travels from the element it occurred on, up to its parent, then up to the parent's parent, and so on, until it reaches the root element, a.k.a. the window. So in our table example, whenever a <code>td</code> is clicked, its parent <code>tr</code> would also be notified of the click, the parent <code>table</code> would be notified, the <code>body</code> would be notified, and ultimately the <code>window</code> would be notified as well. While event bubbling and delegation work well, the delegating element (in our example, the <code>table</code>) should always be as close to the delegatees as possible so the event doesn't have to travel way up the DOM tree before its handler function is called.</p>

                            <p>The two main pros of event delegation over binding directly to an element (or set of elements) are performance and the aforementioned event bubbling.</p>
                            <ul>
                                <li>Imagine having a large table of 1,000 cells and binding to an event for each cell. That's 1,000 separate event handlers that the browser has to attach, even if they're all mapped to the same function. Instead of binding to each individual cell though, we could instead use delegation to listen for events that occur on the parent table and react accordingly. One event would be bound instead of 1,000, resulting in way better performance and memory management.</li>

                                <li>The event bubbling that occurs affords us the ability to add cells via Ajax for example, without having to bind events directly to those cells since the parent table is listening for clicks and is therefore notified of clicks on its children. If we weren't using delegation, we'd have to constantly bind events for every cell that's added which is not only a performance issue, but could also become a maintenance nightmare.</li>
                            </ul>
                            
                            <h4 class="heading">
                                <span id="Delegation-Introduction">Introduction</span>
                                <span class="source"><a href="https://learn.jquery.com/events/event-delegation/#introduction">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Event delegation allows us to attach a single event listener, to a parent element, that will fire for all descendants matching a selector, whether those descendants exist now or are added in the future.</p>
                                
                                <p>Example: For the remainder of the lesson, we will reference the following HTML structure:</p>
                                <pre><code>
                                &lt;html>
                                &lt;body>
                                &lt;div id="container">
                                    &lt;ul id="list">
                                        &lt;li>&lt;a href="http://domain1.com">Item #1&lt;/a>&lt;/li>
                                        &lt;li>&lt;a href="/local/path/1">Item #2&lt;/a>&lt;/li>
                                        &lt;li>&lt;a href="/local/path/2">Item #3&lt;/a>&lt;/li>
                                        &lt;li>&lt;a href="http://domain4.com">Item #4&lt;/a>&lt;/li>
                                    &lt;/ul>
                                &lt;/div>
                                &lt;/body>
                                &lt;/html>
                                </code></pre>
                                
                                <p>When an anchor in our #list group is clicked, we want to log its text to the console. Normally we could directly bind to the click event of each anchor using the <code>.on()</code> method:</p>
                                <pre><code>
                                // Attach a directly bound event handler
                                $( "#list a" ).on( "click", function( event ) {
                                    event.preventDefault();
                                    console.log( $( this ).text() );
                                });
                                </code></pre>
                                
                                <p>While this works perfectly fine, there are drawbacks. Consider what happens when we add a new anchor after having already bound the above listener:</p>
                                <pre><code>
                                // Add a new element on to our existing list
                                $( "#list" ).append( "&lt;li>&lt;a href='http://newdomain.com'>Item #5&lt;/a>&lt;/li>" );
                                </code></pre>
                                
                                <p>If we were to click our newly added item, nothing would happen. This is because of the directly bound event handler that we attached previously. Direct events are only attached to elements at the time the <code>.on()</code> method is called. In this case, since our new anchor did not exist when <code>.on()</code> was called, it does not get the event handler.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Event-Propagation">Event Propagation</span>
                                <span class="source"><a href="https://learn.jquery.com/events/event-delegation/#event-propagation">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Understanding how events propagate is an important factor in being able to leverage Event Delegation. Any time one of our anchor tags is clicked, a click event is fired for that anchor, and then bubbles up the DOM tree, triggering each of its parent click event handlers:</p>
                                <ul>
                                    <li><code>&lt;a></code></li>
                                    <li><code>&lt;li></code></li>
                                    <li><code>&lt;ul #list></code></li>
                                    <li><code>&lt;div #container></code></li>
                                    <li><code>&lt;body></code></li>
                                    <li><code>&lt;html></code></li>
                                    <li><code>document root</code></li>
                                </ul>
                                
                                <p>This means that anytime you click one of our bound anchor tags, you are effectively clicking the entire document body! This is called event bubbling or event propagation.</p>

                                Since we know how events bubble, we can create a delegated event:
                                <pre><code>
                                // Attach a delegated event handler
                                $( "#list" ).on( "click", "a", function( event ) {
                                    event.preventDefault();
                                    console.log( $( this ).text() );
                                });
                                </code></pre>
                                
                                <p>Notice how we have moved the a part from the selector to the second parameter position of the <code>.on()</code> method. This second, selector parameter tells the handler to listen for the specified event, and when it hears it, check to see if the triggering element for that event matches the second parameter. In this case, the triggering event is our anchor tag, which matches that parameter. Since it matches, our anonymous function will execute. We have now attached a single click event listener to our <code>&l6;ul></code> that will listen for clicks on its descendant anchors, instead of attaching an unknown number of directly bound events to the existing anchor tags only.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Using-the-Triggering-Element">Using the Triggering Element</span>
                                <span class="source"><a href="https://learn.jquery.com/events/event-delegation/#using-the-triggering-element">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>What if we wanted to open the link in a new window if that link is an external one (as denoted here by beginning with "http")?</p>
                                <pre><code>
                                // Attach a delegated event handler
                                $( "#list" ).on( "click", "a", function( event ) {
                                    var elem = $( this );
                                    if ( elem.is( "[href^='http']" ) ) {
                                        elem.attr( "target", "_blank" );
                                    }
                                });
                                </code></pre>
                                
                                <p>This simply passes the <code>.is()</code> method a selector to see if the <code>href</code> attribute of the element starts with "http". We have also removed the <code>event.preventDefault()</code>; statement as we want the default action to happen (which is to follow the <code>href</code>).</p>

                                <p>We can actually simplify our code by allowing the selector parameter of <code>.on()</code> do our logic for us:</p>
                                <pre><code>
                                // Attach a delegated event handler with a more refined selector
                                $( "#list" ).on( "click", "a[href^='http']", function( event ) {
                                    $( this ).attr( "target", "_blank" );
                                });
                                </code></pre>
                            </div>
                        </div>

                        <h3 class="heading">
                            <span id="Inside-the-Event-Handler-Function">Inside the Event Handler Function</span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#inside-the-event-handler-function">Source</a></span>
                        </h3>
                        <div class="content">
                            <h4 class="heading">
                                <span id="The-event-object">The event object</span>
                                <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#the-event-object">Source 1</a></span>
                                <span class="source"><a href="https://learn.jquery.com/events/event-basics/#inside-the-event-handler-function">Source 2</a></span>
                            </h4>
                            <div class="content">
                                <p>In all of the previous examples, we've been using anonymous functions and specifying an event argument within that function. Let's change it up a little bit.</p>
                                <pre><code>
                                // Binding a named function
                                function sayHello( event ) {
                                    alert( "Hello." );
                                }

                                $( "#helloBtn" ).on( "click", sayHello );
                                </code></pre>

                                <p>In this slightly different example, we're defining a function called <code>sayHello</code> and then passing that function into the on method instead of an anonymous function. So many online examples show anonymous functions used as event handlers, but it's important to realize that you can also pass defined functions as event handlers as well. This is important if different elements or different events should perform the same functionality. This helps to keep your code <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>.</p>

                                <p>But what about that event argument in the <code>sayHello</code> function — what is it and why does it matter? In all DOM event callbacks, jQuery passes an event object argument which contains information about the event, such as precisely when and where it occurred, what type of event it was, which element the event occurred on, and a plethora of other information. Of course you don't have to call it <code>event</code>; you could call it <code>e</code> or whatever you want to, but <code>event</code> is a pretty common convention.</p>

                                <p>The event object is most commonly used to prevent the default action of the event via the <code>.preventDefault()</code> method. However, the event object contains a number of other useful properties and methods, including:</p>
                                <ul>
                                    <li><em>pageX, pageY</em>: The mouse position at the time the event occurred, relative to the top left corner of the page display area (not the entire browser window).</li>

                                    <li><em>linktype</em>: The type of the event (e.g., "click").</li>

                                    <li><em>linkwhich</em>: The button or key that was pressed.</li>

                                    <li><em>linkdata</em>: Any data that was passed in when the event was bound. For example:</li>
                                    <pre><code>
                                    // Event setup using the `.on()` method with data
                                    $( "input" ).on(
                                        "change",
                                        { foo: "bar" }, // Associate data with event binding
                                        function( eventObject ) {
                                            console.log("An input value has changed! ", eventObject.data.foo);
                                        }
                                    );
                                    </code></pre>

                                    <li><em>target</em>: The DOM element that initiated the event.</li>

                                    <li><em>linknamespace</em>: The namespace specified when the event was triggered.</li>

                                    <li><em>linktimeStamp</em>: The difference in milliseconds between the time the event occurred in the browser and January 1, 1970.</li>

                                    <li><em>linkpreventDefault()</em>: Prevent the default action of the event (e.g. following a link).</li>

                                    <li><em>linkstopPropagation()</em>: Stop the event from bubbling up to other elements.</li>
                                </ul>

                                <h5 class="heading command">
                                    <span id="preventDefault-stopPropagation"><code>.preventDefault()</code> and <code>.stopPropagation()</code></span>
                                    <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#the-event-object">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>If the element has default functionality for a specific event (like a link opens a new page, a button in a form submits the form, etc.), that default functionality can be canceled. This is often useful for Ajax requests. When a user clicks on a button to submit a form via Ajax, we'd want to cancel the button/form's default action (to submit it to the form's <code>action</code> attribute), and we would instead do an Ajax request to accomplish the same task for a more seamless experience. To do this, we would utilize the event object and call its <code>.preventDefault()</code> method.</p>

                                    <p>We can also prevent the event from bubbling up the DOM tree using <code>.stopPropagation()</code> so that parent elements aren't notified of its occurrence (in the case that event delegation is being used).</p>

                                    <pre><code>
                                    // Preventing a default action from occurring and stopping the event bubbling
                                    $( "form" ).on( "submit", function( event ) {

                                        // Prevent the form's default submission.
                                        event.preventDefault();

                                        // Prevent event from bubbling up DOM tree, prohibiting delegation
                                        event.stopPropagation();

                                        // Make an AJAX request to submit the form data
                                    });
                                    </code></pre>

                                    <p>When utilizing both <code>.preventDefault()</code> and <code>.stopPropagation()</code> simultaneously, you can instead <code>return false</code> to achieve both in a more concise manner, but it's advisable to only <code>return false</code> when both are actually necessary and not just for the sake of terseness.</p> 

                                    <p>A final note on <code>.stopPropagation()</code> is that when using it in delegated events, the soonest that event bubbling can be stopped is when the event reaches the element that is delegating it.</p>
                                </div>

                                <h5 class="heading command">
                                    <span id="originalEvent"><code>originalEvent</code></span>
                                    <span class="source"><a href="https://learn.jquery.com/events/introduction-to-events/#the-event-object">Source</a></span>
                                </h5>
                                <div class="content">
                                    <p>It's also important to note that the event object contains a property called <code>originalEvent</code>, which is the event object that the browser itself created. jQuery wraps this native event object with some useful methods and properties, but in some instances, you'll need to access the original event via <code>event.originalEvent</code> for instance. This is especially useful for touch events on mobile devices and tablets.</p>
                                </div>

                                <p>Finally, to inspect the event itself and see all of the data it contains, you should log the event in the browser's console using <code>console.log</code>. This will allow you to see all of an event's properties (including the <code>originalEvent</code>) which can be really helpful for debugging.</p>
                                <pre><code>
                                // Logging an event's information
                                $( "form" ).on( "submit", function( event ) {

                                    // Prevent the form's default submission.
                                    event.preventDefault();

                                    // Log the event object for inspectin'
                                    console.log( event );

                                    // Make an AJAX request to submit the form data
                                });
                                </code></pre>
                            </div>

                            <h4 class="heading">
                                <span id="event-this">the DOM element that initiated the event - <code>this</code></span>
                                <span class="source"><a href="https://learn.jquery.com/events/event-basics/#inside-the-event-handler-function">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>In addition to the event object, the event handling function also has access to the DOM element that the handler was bound to via the keyword <code>this</code>. To turn the DOM element into a jQuery object that we can use jQuery methods on, we simply do <code>$( this )</code>, often following this idiom:</p>
                                <pre><code>
                                var element = $( this );
                                </code></pre>
                                <p>A fuller example would be:</p>
                                <pre><code>
                                // Preventing a link from being followed
                                $( "a" ).click(function( eventObject ) {
                                    var elem = $( this );
                                    if ( elem.attr( "href" ).match( /evil/ ) ) {
                                        eventObject.preventDefault();
                                        elem.addClass( "evil" );
                                    }
                                });
                                </code></pre>
                            </div>
                        </div>

                        <h3 class="heading">
                            <span id="Setting-Up-Multiple-Event-Responses">Setting Up Multiple Event Responses</span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#setting-up-multiple-event-responses">Source</a></span>
                        </h3>
                        <div class="content">
                            <ul>
                                <li>Quite often elements in your application will be bound to multiple events. If multiple events are to share the same handling function, you can provide the event types as a space-separated list to <code>.on()</code>:</li>
                                <pre><code>
                                // Multiple events, same handler
                                $( "input" ).on(
                                    "click change", // Bind handlers for multiple events
                                    function() {
                                        console.log( "An input was clicked or changed!" );
                                    }
                                );
                                </code></pre>

                                <li>When each event has its own handler, you can pass an object into <code>.on()</code> with one or more key/value pairs, with the key being the event name and the value being the function to handle the event.</li>
                                <pre><code>
                                // Binding multiple events with different handlers
                                $( "p" ).on({
                                    "click": function() { console.log( "clicked!" ); },
                                    "mouseover": function() { console.log( "hovered!" ); }
                                });
                                </code></pre>
                            </ul>
                        </div>

                        <h3 class="heading">
                            <span id="Namespacing-Events">Namespacing Events</span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#namespacing-events">Source 1</a></span>
                            <span class="source"><a href="https://learn.jquery.com/events/handling-events/#namespacing-events">Source 2</a></span>
                        </h3>
                        <div class="content">
                            <p>For complex applications and for plugins you share with others, it can be useful to namespace your events so you don't unintentionally disconnect events that you didn't or couldn't know about.</p>
                            <pre><code>
                            // Namespacing events
                            $( "p" ).on( "click.myNamespace", function() { /* ... */ } );
                            $( "p" ).off( "click.myNamespace" );
                            $( "p" ).off( ".myNamespace" ); // Unbind all events in the namespace
                            </code></pre>
                        </div>

                        <h3 class="heading">
                            <span id="off">Disconnecting Events - <code>.off()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#tearing-down-event-listeners">Source 1</a></span>
                            <span class="source"><a href="https://learn.jquery.com/events/handling-events/#disconnecting-events">Source 2</a></span>
                        </h3>
                        <div class="content">
                            <p>Although all the fun of jQuery occurs in the <code>.on()</code> method, its counterpart is just as important if you want to be a responsible developer. <code>.off()</code> cleans up that event binding when you don't need it anymore. Complex user interfaces with lots of event bindings can bog down browser performance, so using the <code>.off()</code> method diligently is a best practice to ensure that you only have the event bindings that you need, when you need them.</p>
                            
                            <p>To remove an event listener, you use the <code>.off()</code> method and pass in the event type to off. If you attached a named function to the event, then you can isolate the event tear down to just that named function by passing it as the second argument.</p>
                            <pre><code>
                            // Tearing down all click handlers on a selection
                            $( "p" ).off( "click" );

                            // Tearing down a particular click handler, using a reference to the function
                            var foo = function() { console.log( "foo" ); };
                            var bar = function() { console.log( "bar" ); };

                            $( "p" ).on( "click", foo ).on( "click", bar );
                            $( "p" ).off( "click", bar ); // foo is still bound to the click event
                            </code></pre>
                        </div>

                        <h3 class="heading">
                            <span id="one">Connecting Events to Run Only Once - <code>.one()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-basics/#setting-up-events-to-run-only-once">Source 1</a></span>
                            <span class="source"><a href="https://learn.jquery.com/events/handling-events/#connecting-events-to-run-only-once">Source 2</a></span>
                        </h3>
                        <div class="content">
                            <ul>
                                <li>Sometimes you need a particular handler to run only once — after that, you may want no handler to run, or you may want a different handler to run. jQuery provides the <code>.one()</code> method for this purpose.</li>
                                <pre><code>
                                // Switching handlers using the `.one()` method
                                $( "p" ).one( "click", firstClick );

                                function firstClick() {
                                    console.log( "You just clicked this for the first time!" );

                                    // Now set up the new handler for subsequent clicks;
                                    // omit this step if no further click responses are needed
                                    $( this ).click( function() { console.log( "You have clicked this before!" ); } );
                                }
                                </code></pre>
                                <p>Note that in the code snippet above, the <code>firstClick</code> function will be executed for the first click on each paragraph element rather than the function being removed from all paragraphs when any paragraph is clicked for the first time.</p>
                                
                                <li>The <code>.one()</code> method is especially useful if you need to do some complicated setup the first time an element is clicked, but not subsequent times.</li>
                                
                                <li><code>.one()</code> accepts the same arguments as <code>.on()</code> which means it supports multiple events to one or multiple handlers, passing custom data and event delegation.</li>

                                <p>For example, <code>.one()</code> can also be used to bind multiple events:</p>
                                <pre><code>
                                // Using .one() to bind several events
                                $( "input[id]" ).one( "focus mouseover keydown", firstEvent);

                                function firstEvent( eventObject ) {
                                    console.log( "A " + eventObject.type + " event occurred for the first time on the input with id " + this.id );
                                }
                                </code></pre>
                                <p>In this case, the <code>firstEvent</code> function will be executed once for each event. For the snippet above, this means that once an input element gains focus, the handler function will still execute for the first keydown event on that element.</p>
                            </ul>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Triggering-Event-Handlers">Triggering Event Handlers</span>
                            <span class="source"><a href="https://learn.jquery.com/events/triggering-event-handlers/">Source</a></span>
                        </h3>
                        
                        <h3 class="heading">
                            <span id="History-of-jQuery-Events">History of jQuery Events</span>
                            <span class="source"><a href="https://learn.jquery.com/events/history-of-events/">Source</a></span>
                        </h3>
                        
                        <h3 class="heading">
                            <span id="Introducing-Custom-Events">Introducing Custom Events</span>
                            <span class="source"><a href="https://learn.jquery.com/events/introduction-to-custom-events/">Source</a></span>
                        </h3>
                        
                        <h3 class="heading">
                            <span id="jQuery-Event-Extensions">jQuery Event Extensions</span>
                            <span class="source"><a href="https://learn.jquery.com/events/event-extensions/">Source</a></span>
                        </h3>
                    </div>
                    
                    <h2 class="heading">
                        <span id="Effects">Effects</span>
                        <span class="source"><a href="https://learn.jquery.com/effects/">Source</a></span>
                    </h2>
                    <div class="content">
                        <p>jQuery makes it trivial to add simple effects to your page. Effects can use the built-in settings, or provide a customized duration. You can also create custom animations of arbitrary CSS properties.</p>

                        <p>For complete details on jQuery effects, visit the <a href="http://api.jquery.com/category/effects/">Effects documentation on api.jquery.com</a>.</p>
                        
                        <h3 class="heading">
                            <span id="Showing-and-Hiding-Content">Showing and Hiding Content - <code>.show()</code> and <code>.hide()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#showing-and-hiding-content">Source</a></span>
                        </h3>
                        <div class="content">
                            <ul>
                                <li>jQuery can show or hide content instantaneously with <code>.show()</code> or <code>.hide()</code>:</li>
                                <pre><code>
                                // Instantaneously hide all paragraphs
                                $( "p" ).hide();

                                // Instantaneously show all divs that have the hidden style class
                                $( "div.hidden" ).show();
                                </code></pre>
                                
                                <p>When jQuery hides an element, it sets its CSS <code>display</code> property to <code>none</code>. This means the content will have zero width and height; it does not mean that the content will simply become transparent and leave an empty area on the page.</p>

                                <li>jQuery can also show or hide content by means of animation effects. You can tell <code>.show()</code> and <code>.hide()</code> to use animation in a couple of ways. One is to pass in an argument of <code>'slow'</code>, <code>'normal'</code>, or <code>'fast'</code>:</li>
                                <pre><code>
                                // Slowly hide all paragraphs
                                $( "p" ).hide( "slow" );

                                // Quickly show all divs that have the hidden style class
                                $( "div.hidden" ).show( "fast" );
                                </code></pre>
                                
                                <li>If you prefer more direct control over the duration of the animation effect, you can pass the desired duration in milliseconds to <code>.show()</code> and <code>.hide()</code>:</li>
                                <pre><code>
                                // Hide all paragraphs over half a second
                                $( "p" ).hide( 500 );

                                // Show all divs that have the hidden style class over 1.25 seconds
                                $( "div.hidden" ).show( 1250 );
                                </code></pre>
                                
                                <p>Most developers pass in a number of milliseconds to have more precise control over the duration.</p>
                            </ul>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Fade-and-Slide-Animations">Fade and Slide Animations - <code>.fadeIn()</code>, <code>.fadeOut()</code>, <code>.slideDown()</code> and <code>.slideUp()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#fade-and-slide-animations">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>You may have noticed that <code>.show()</code> and <code>.hide()</code> use a combination of slide and fade effects when showing and hiding content in an animated way. If you would rather show or hide content with one effect or the other, there are additional methods that can help.</p>
                                
                            <p><code>.slideDown()</code> and <code>.slideUp()</code> show and hide content, respectively, using only a slide effect. Slide animations are accomplished by rapidly making changes to an element's CSS <code>height</code> property.</p>
                            <pre><code>
                            // Hide all paragraphs using a slide up animation over 0.8 seconds
                            $( "p" ).slideUp( 800 );

                            // Show all hidden divs using a slide down animation over 0.6 seconds
                            $( "div.hidden" ).slideDown( 600 );
                            </code></pre>
                            
                            <p>Similarly <code>.fadeIn()</code> and <code>.fadeOut()</code> show and hide content, respectively, by means of a fade animation. Fade animations involve rapidly making changes to an element's CSS <code>opacity</code> property.</p>
                            <pre><code>
                            // Hide all paragraphs using a fade out animation over 1.5 seconds
                            $( "p" ).fadeOut( 1500 );

                            // Show all hidden divs using a fade in animation over 0.75 seconds
                            $( "div.hidden" ).fadeIn( 750 );
                            </code></pre>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Changing-Display-Based-on-Current-Visibility-State">Changing Display Based on Current Visibility State - <code>.toggle()</code>, <code>.slideToggle()</code> and <code>.fadeToggle()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#changing-display-based-on-current-visibility-state">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>jQuery can also let you change a content's visibility based on its current visibility state. <code>.toggle()</code> will show content that is currently hidden and hide content that is currently visible. You can pass the same arguments to <code>.toggle()</code> as you pass to any of the effects methods above.</p>
                            <pre><code>
                            // Instantaneously toggle the display of all paragraphs
                            $( "p" ).toggle();

                            // Slowly toggle the display of all images
                            $( "img" ).toggle( "slow" );

                            // Toggle the display of all divs over 1.8 seconds
                            $( "div" ).toggle( 1800 );
                            </code></pre>
                            
                            <p><code>.toggle()</code> will use a combination of slide and fade effects, just as <code>.show()</code> and <code>.hide()</code> do. You can toggle the display of content with just a slide or a fade using <code>.slideToggle()</code> and <code>.fadeToggle()</code>.</p>
                            <pre><code>
                            // Toggle the display of all ordered lists over 1 second using slide up/down animations
                            $( "ol" ).slideToggle( 1000 );

                            // Toggle the display of all blockquotes over 0.4 seconds using fade in/out animations
                            $( "blockquote" ).fadeToggle( 400 );
                            </code></pre>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Doing-Something-After-an-Animation-Completes">Doing Something After an Animation Completes</span>
                            <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#doing-something-after-an-animation-completes">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>A common mistake when implementing jQuery effects is assuming that the execution of the next method in your chain will wait until the animation runs to completion.</p>
                            <pre><code>
                            // Fade in all hidden paragraphs; then add a style class to them (not quite right)
                            $( "p.hidden" ).fadeIn( 750 ).addClass( "lookAtMe" );
                            </code></pre>
                            
                            <p>It is important to realize that <code>.fadeIn()</code> above only kicks off the animation. Once started, the animation is implemented by rapidly changing CSS properties in a JavaScript <code>setInterval()</code> loop. When you call <code>.fadeIn()</code>, it starts the animation loop and then returns the jQuery object, passing it along to <code>.addClass()</code> which will then add the <code>lookAtMe</code> style class while the animation loop is just getting started.</p>

                            <p>To defer an action until after an animation has run to completion, you need to use an animation callback function. You can specify your animation callback as the second argument passed to any of the animation methods discussed above. For the code snippet above, we can implement a callback as follows:</p>
                            <pre><code>
                            // Fade in all hidden paragraphs; then add a style class to them (correct with animation callback)
                            $( "p.hidden" ).fadeIn( 750, function() {
                                // this = DOM element which has just finished being animated
                                $( this ).addClass( "lookAtMe" );
                            });
                            </code></pre>
                            
                            <p>Note that you can use the keyword <code>this</code> to refer to the DOM element being animated. Also note that the callback will be called for each element in the jQuery object. This means that if your selector returns no elements, your animation callback will never run! You can solve this problem by testing whether your selection returned any elements; if not, you can just run the callback immediately.</p>
                            <pre><code>
                            // Run a callback even if there were no elements to animate
                            var someElement = $( "#nonexistent" );

                            var cb = function() {
                                console.log( "done!" );
                            };

                            if ( someElement.length ) {
                                someElement.fadeIn( 300, cb );
                            } else {
                                cb();
                            }
                            </code></pre>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Managing-Animation-Effects">Managing Animation Effects</span>
                            <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#managing-animation-effects">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>jQuery provides some additional features for controlling your animations:</p>
                            
                            <h4 class="heading command">
                                <span id="stop"><code>.stop()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#stop-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p><code>.stop()</code> will immediately terminate all animations running on the elements in your selection. You might give end-users control over page animations by rigging a button they can click to stop the animations.</p>
                                <pre><code>
                                // Create a button to stop all animations on the page:
                                $( "&lt;button type='button'>&lt;/button>" )
                                    .text( "Stop All Animations" )
                                    .on( "click", function() {
                                        $( "body *" ).filter( ":animated" ).stop();
                                    })
                                    .appendTo( document.body );
                                </code></pre>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="delay"><code>.delay()</code></span>
                                <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#delay-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>.delay() is used to introduce a delay between successive animations. For example:</p>
                                <pre><code>
                                // Hide all level 1 headings over half a second; then wait for 1.5 seconds
                                // and reveal all level 1 headings over 0.3 seconds
                                $( "h1" ).hide( 500 ).delay( 1500 ).show( 300 );
                                </code></pre>
                            </div>
                            
                            <h4 class="heading command">
                                <span id="jQuery-fx"><code>jQuery.fx</code></span>
                                <span class="source"><a href="https://learn.jquery.com/effects/intro-to-effects/#jquery-fx">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The jQuery.fx object has a number of properties that control how effects are implemented.</p>
                                
                                <ul>
                                    <li><code>jQuery.fx.speeds</code>code>: maps the slow, normal, and fast duration arguments mentioned above to a specific number of milliseconds. The default value of <code>jQuery.fx.speeds</code> is:</li>
                                    <pre><code>
                                    {
                                        slow: 600,
                                        fast: 200,
                                        _default: 400 // Default speed, used for "normal"
                                    }
                                    </code></pre>
                                    
                                    <p>You can modify any of these settings and even introduce some of your own:</p>
                                    <pre><code>
                                    jQuery.fx.speeds.fast = 300;
                                    jQuery.fx.speeds.blazing = 100;
                                    jQuery.fx.speeds.excruciating = 60000;
                                    </code></pre>
                                    
                                    <li><code>jQuery.fx.interval</code>: controls the number of frames per second that is displayed in an animation. The default value is 13 milliseconds between successive frames. You can set this to a lower value for faster browsers to make the animations run smoother. However this will mean more frames per second and thus a higher computational load for the browser, so you should be sure to test the performance implications of doing so thoroughly.</li>
                                    
                                    <li>Finally, <code>jQuery.fx.off</code>: can be set to true to disable all animations. Elements will immediately be set to the target final state instead. This can be especially useful when dealing with older browsers; you also may want to provide the option to disable all animations to your users.</li>
                                    <pre><code>
                                    $( "&lt;button type='button'>&lt;/button>" )
                                    .text( "Disable Animations" )
                                    .on( "click", function() {
                                        jQuery.fx.off = true;
                                    })
                                    .appendTo( document.body );
                                    </code></pre>
                                </ul>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Custom-Effects">Custom Effects with <code>.animate()</code></span>
                            <span class="source"><a href="https://learn.jquery.com/effects/custom-effects/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>jQuery makes it possible to animate arbitrary CSS properties via the <code>.animate()</code> method. The <code>.animate()</code> method lets you animate to a set value, or to a value relative to the current value.</p>
                            <pre><code>
                            // Custom effects with .animate()
                            $( "div.funtimes" ).animate(
                                {
                                    left: "+=50",
                                    opacity: 0.25
                                },

                                // Duration
                                300,

                                // Callback to invoke when the animation is finished
                                function() {
                                    console.log( "done!" );
                                }
                            );
                            </code></pre>
                            
                            <p>Note: Color-related properties cannot be animated with <code>.animate()</code> using jQuery out of the box. Color animations can easily be accomplished by including the <a href="https://github.com/jquery/jquery-color">color plugin</a>. We'll discuss using plugins later in the book.</p>
                            
                            <h4 class="heading">
                                <span id="Easing">Easing</span>
                                <span class="source"><a href="https://learn.jquery.com/effects/custom-effects/#easing">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Definition: Easing describes the manner in which an effect occurs — whether the rate of change is steady, or varies over the duration of the animation. jQuery includes only two methods of easing: <code>swing</code> and <code>linear</code>. If you want more natural transitions in your animations, various easing plugins are available.</p>

                                <p>As of jQuery 1.4, it is possible to do per-property easing when using the <code>.animate()</code> method.</p>
                                <pre><code>
                                // Per-property easing
                                $( "div.funtimes" ).animate({
                                    left: [ "+=50", "swing" ],
                                    opacity: [ 0.25, "linear" ]
                                }, 300 );
                                </code></pre>
                                
                                <p>For more details on easing options, see <a href="http://api.jquery.com/animate/">Animation documentation on api.jquery.com</a>.</p>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Queue-Dequeue-Explained">Queue & Dequeue Explained</span>
                            <span class="source"><a href="https://learn.jquery.com/effects/queue-and-dequeue-explained/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>Queues are the foundation for all animations in jQuery, they allow a series functions to be executed asynchronously on an element. Methods such as <code>.slideUp()</code>, <code>.slideDown()</code>, <code>.fadeIn()</code>, and <code>.fadeOut()</code> all use <code>.animate()</code>, which leverages queues to build up the series of steps that will transition one or more CSS values throughout the duration of the animation.</p>

                            <p>We can pass a callback function to the <code>.animate()</code> method, which will execute once the animation has completed.</p>
                            <pre><code>
                            $( ".box" )
                                .animate( {
                                    height: 20
                                }, "slow", function() {
                                    $( "#title" ).html( "We're in the callback, baby!" );
                                } );
                            </code></pre>
                            
                            <h4 class="heading">
                                <span id="Queues-As-Callbacks">Queues As Callbacks</span>
                                <span class="source"><a href="https://learn.jquery.com/effects/queue-and-dequeue-explained/#queues-as-callbacks">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Instead of passing a callback as an argument, we can add another function to the queue that will act as our callback. This will execute after all of the steps in the animation have completed.</p>
                                <pre><code>
                                $( ".box" )
                                    .animate( {
                                        height: 20
                                    }, "slow")
                                    .queue( function() {
                                        $( "#title" ).html( "We're in the animation, baby!" );

                                        // This tells jQuery to continue to the next item in the queue
                                        $( this ).dequeue();
                                    } );
                                </code></pre>
                                
                                <p>In this example, the queued function will execute right after the animation.</p>

                                <p>jQuery does not have any insight into how the queue items function, so we need to call <code>.dequeue()</code>, which tells jQuery when to move to the next item in the queue.</p>

                                <p>Another way of dequeuing is by calling the function that is passed to your callback. That function will automatically call <code>.dequeue()</code> for you.</p>
                                <pre><code>
                                .queue( function( next ) {
                                    console.log( "I fired!" );
                                    next();
                                } );
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Custom-Queues">Custom Queues</span>
                                <span class="source"><a href="https://learn.jquery.com/effects/queue-and-dequeue-explained/#custom-queues">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Up to this point all of our animation and queue examples have been using the default queue name which is <code>fx</code>. Elements can have multiple queues attached to them, and we can give each of these queues a different name. We can specify a custom queue name as the first argument to the <code>.queue()</code> method.
                                <pre><code>
                                $( ".box" )
                                    .queue( "steps", function( next ) {
                                        console.log( "Step 1" );
                                        next();
                                    } )
                                    .queue( "steps", function( next ) {
                                        console.log( "Step 2" );
                                        next();
                                    } )
                                    .dequeue( "steps" );
                                </code></pre>
                                
                                <p>Notice that we have to call the <code>.dequeue()</code> method passing it the name of our custom queue to start the execution. Every queue except for the default, <code>fx</code>, has to be manually kicked off by calling <code>.dequeue()</code> and passing it the name of the queue.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Clearing-The-Queue">Clearing The Queue</span>
                                <span class="source"><a href="https://learn.jquery.com/effects/queue-and-dequeue-explained/#clearing-the-queue">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Since queues are just a set of ordered operations, our application may have some logic in place that needs to prevent the remaining queue entries from executing. We can do this by calling the <code>.clearQueue()</code> method, which will empty the queue.</p>
                                <pre><code>
                                $( ".box" )
                                    .queue( "steps", function( next ) {
                                        console.log( "Will never log because we clear the queue" );
                                        next();
                                    } )
                                    .clearQueue( "steps" )
                                    .dequeue( "steps" );
                                </code></pre>
                                
                                <p>In this example, nothing will happen as we removed everything from the steps queue.</p>

                                <p>Another way of clearing the queue is to call <code>.stop( true )</code>. That will stop the currently running animations and will clear the queue.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Replacing-The-Queue">Replacing The Queue</span>
                                <span class="source"><a href="https://learn.jquery.com/effects/queue-and-dequeue-explained/#replacing-the-queue">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>When you pass an array of functions as the second argument to <code>.queue()</code>, that array will replace the queue.</p>
                                <pre><code>
                                $( ".box" )
                                    .queue( "steps", function( next ) {
                                        console.log( "I will never fire as we totally replace the queue" );
                                        next();
                                    } )
                                    .queue( "steps", [
                                        function( next ) {
                                            console.log( "I fired!" );
                                            next();
                                        }
                                    ] )
                                    .dequeue( "steps" );
                                </code></pre>
                                
                                <p>You can also call <code>.queue()</code> without passing it functions, which will return the queue of that element as an array.</p>
                                <pre><code>
                                $( ".box" ).queue( "steps", function( next ) {
                                    console.log( "I fired!" );
                                    next();
                                } );

                                console.log( $( ".box" ).queue( "steps" ) );

                                $( ".box" ).dequeue( "steps" );
                                </code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <h2 class="heading">
                        <span id="Ajax">Ajax</span>
                        <span class="source"><a href="https://learn.jquery.com/ajax/">Source</a></span>
                    </h2>
                    <div class="content">
                        <p>Traditionally webpages required reloading to update their content. For web-based email this meant that users had to manually reload their inbox to check and see if they had new mail. This had huge drawbacks: it was slow and it required user input. When the user reloaded their inbox, the server had to reconstruct the entire web page and resend all of the HTML, CSS, JavaScript, as well as the user's email. This was hugely inefficient. Ideally, the server should only have to send the user's new messages, not the entire page. By 2003, all the major browsers solved this issue by adopting the XMLHttpRequest (XHR) object, allowing browsers to communicate with the server without requiring a page reload.</p>

                        <p>The XMLHttpRequest object is part of a technology called Ajax (Asynchronous JavaScript and XML). Using Ajax, data could then be passed between the browser and the server, using the XMLHttpRequest API, without having to reload the web page. With the widespread adoption of the XMLHttpRequest object it quickly became possible to build web applications like Google Maps, and Gmail that used XMLHttpRequest to get new map tiles, or new email without having to reload the entire page.</p>

                        <p>Ajax requests are triggered by JavaScript code; your code sends a request to a URL, and when it receives a response, a callback function can be triggered to handle the response. Because the request is asynchronous, the rest of your code continues to execute while the request is being processed, so it's imperative that a callback be used to handle the response.</p>

                        <p>Unfortunately, different browsers implement the Ajax API differently. Typically this meant that developers would have to account for all the different browsers to ensure that Ajax would work universally. Fortunately, jQuery provides Ajax support that abstracts away painful browser differences. It offers both a full-featured <code>$.ajax()</code> method, and simple convenience methods such as <code>$.get()</code>, <code>$.getScript()</code>, <code>$.getJSON()</code>, <code>$.post()</code>, and <code>$().load()</code>.</p>

                        <p>Most jQuery applications don't in fact use XML, despite the name "Ajax"; instead, they transport data as plain HTML or JSON (JavaScript Object Notation).</p>

                        <p>In general, Ajax does not work across domains. For instance, a webpage loaded from example1.com is unable to make an Ajax request to example2.com as it would violate the same origin policy. As a work around, JSONP (JSON with Padding) uses <code>&lt;script></code> tags to load files containing arbitrary JavaScript content and JSON, from another domain. More recently browsers have implemented a technology called Cross-Origin Resource Sharing (CORS), that allows Ajax requests to different domains.</p>
                        
                        <h3 class="heading">
                            <span id="Key-Concepts">Key Concepts</span>
                            <span class="source"><a href="https://learn.jquery.com/ajax/key-concepts/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>Proper use of Ajax-related jQuery methods requires understanding some key concepts first.</p>
                            
                            <h4 class="heading">
                                <span id="GET-vs-POST">GET vs. POST</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/key-concepts/#get-vs-post">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The two most common "methods" for sending a request to a server are GET and POST. It's important to understand the proper application of each.</p>
                                <ul>
                                    <li>The GET method should be used for non-destructive operations — that is, operations where you are only "getting" data from the server, not changing data on the server. For example, a query to a search service might be a GET request. GET requests may be cached by the browser, which can lead to unpredictable behavior if you are not expecting it. GET requests generally send all of their data in a query string.</li>

                                    <li>The POST method should be used for destructive operations — that is, operations where you are changing data on the server. For example, a user saving a blog post should be a POST request. POST requests are generally not cached by the browser; a query string can be part of the URL, but the data tends to be sent separately as post data.</li>
                                </ul>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Data-Types">Data Types</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/key-concepts/#data-types">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery generally requires some instruction as to the type of data you expect to get back from an Ajax request; in some cases the data type is specified by the method name, and in other cases it is provided as part of a configuration object. There are several options:</p>
                                <ul>
                                    <li><em>text</em>: For transporting simple strings.</li>

                                    <li><em>html</em>: For transporting blocks of HTML to be placed on the page.</li>

                                    <li><em>cript</em>: For adding a new script to the page.</li>

                                    <li><em>json</em>: For transporting JSON-formatted data, which can include strings, arrays, and objects.</li>

                                    <p>Note: As of jQuery 1.4, if the JSON data sent by your server isn't properly formatted, the request may fail silently. See <a href="http://json.org/">http://json.org</a> for details on properly formatting JSON, but as a general rule, use built-in language methods for generating JSON on the server to avoid syntax issues.</p>

                                    <li><em>jsonp</em>: For transporting JSON data from another domain.</li>

                                    <li><em>xml</em>: For transporting data in a custom XML schema.</li>
                                </ul>
                                
                                <p>Consider using the JSON format in most cases, as it provides the most flexibility. It is especially useful for sending both HTML and data at the same time.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="A-is-for-Asynchronous">A is for Asynchronous</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/key-concepts/#a-is-for-asynchronous">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The asynchronicity of Ajax catches many new jQuery users off guard. Because Ajax calls are asynchronous by default, the response is not immediately available. Responses can only be handled using a callback. So, for example, the following code will not work:</p>
                                <pre><code>
                                var response;

                                $.get( "foo.php", function( r ) {
                                    response = r;
                                });

                                console.log( response ); // undefined
                                </code></pre>
                                
                                <p>Instead, we need to pass a callback function to our request; this callback will run when the request succeeds, at which point we can access the data that it returned, if any.</p>
                                <pre><code>
                                $.get( "foo.php", function( response ) {
                                    console.log( response ); // server response
                                });
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Same-Origin-Policy-and-JSONP">Same-Origin Policy and JSONP</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/key-concepts/#same-origin-policy-and-jsonp">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>In general, Ajax requests are limited to the same protocol (http or https), the same port, and the same domain as the page making the request. This limitation does not apply to scripts that are loaded via jQuery's Ajax methods.</p>

                                <p>Note: Versions of Internet Explorer less than 10 do not support cross-domain AJAX requests.</p>

                                <p>The other exception is requests targeted at a JSONP service on another domain. In the case of JSONP, the provider of the service has agreed to respond to your request with a script that can be loaded into the page using a <code>&lt;script></code> tag, thus avoiding the same-origin limitation; that script will include the data you requested, wrapped in a callback function you provide.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Ajax-and-Firebug">Ajax and Firebug</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/key-concepts/#ajax-and-firebug">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Firebug (or the Webkit Inspector in Chrome or Safari) is an invaluable tool for working with Ajax requests. You can see Ajax requests as they happen in the Console tab of Firebug (and in the Resources > XHR panel of Webkit Inspector), and you can click on a request to expand it and see details such as the request headers, response headers, response content, and more. If something isn't going as expected with an Ajax request, this is the first place to look to track down what's wrong.</p>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="jQuery-s-Ajax-Related-Methods">jQuery’s Ajax-Related Methods</span>
                            <span class="source"><a href="https://learn.jquery.com/ajax/jquery-ajax-methods/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>While jQuery does offer many Ajax-related convenience methods, the core <code>$.ajax()</code> method is at the heart of all of them, and understanding it is imperative. We'll review it first, and then touch briefly on the convenience methods.</p>

                            <p>It's often considered good practice to use the <code>$.ajax()</code> method over the jQuery provided <a href="https://learn.jquery.com/ajax/jquery-ajax-methods/#convenience-methods">convenience methods</a>. As you'll see, it offers features that the convenience methods do not, and its syntax allows for the ease of readability.</p>
                            
                            <h4 class="heading">
                                <span id="Ajax-method"><code>$.ajax()</code> method</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/jquery-ajax-methods/#ajax-">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>jQuery’s core <code>$.ajax()</code> method is a powerful and straightforward way of creating Ajax requests. It takes a configuration object that contains all the instructions jQuery requires to complete the request. The <code>$.ajax()</code> method is particularly valuable because it offers the ability to specify both success and failure callbacks. Also, its ability to take a configuration object that can be defined separately makes it easier to write reusable code. For complete documentation of the configuration options, visit <a href="http://api.jquery.com/jQuery.ajax/">http://api.jquery.com/jQuery.ajax/</a>.</p>
                                <pre><code>
                                // Using the core $.ajax() method
                                $.ajax({

                                    // The URL for the request
                                    url: "post.php",

                                    // The data to send (will be converted to a query string)
                                    data: {
                                        id: 123
                                    },

                                    // Whether this is a POST or GET request
                                    type: "GET",

                                    // The type of data we expect back
                                    dataType : "json",
                                })
                                  // Code to run if the request succeeds (is done);
                                  // The response is passed to the function
                                  .done(function( json ) {
                                     $( "&lt;h1>" ).text( json.title ).appendTo( "body" );
                                     $( "&lt;div class=\"content\">").html( json.html ).appendTo( "body" );
                                  })
                                  // Code to run if the request fails; the raw request and
                                  // status codes are passed to the function
                                  .fail(function( xhr, status, errorThrown ) {
                                    alert( "Sorry, there was a problem!" );
                                    console.log( "Error: " + errorThrown );
                                    console.log( "Status: " + status );
                                    console.dir( xhr );
                                  })
                                  // Code to run regardless of success or failure;
                                  .always(function( xhr, status ) {
                                    alert( "The request is complete!" );
                                  });
                                </code></pre>
                                
                                <p>Note: Regarding the <code>dataType</code> setting, if the server sends back data that is in a different format than you specify, your code may fail, and the reason will not always be clear, because the HTTP response code will not show an error. When working with Ajax requests, make sure your server is sending back the data type you're asking for, and verify that the <code>Content-type</code> header is accurate for the data type. For example, for JSON data, the <code>Content-type</code> header should be <code>application/json</code></p>
                                
                                <p>There are many, many options for the <code>$.ajax()</code> method, which is part of its power. For a complete list of options, visit <a href="http://api.jquery.com/jQuery.ajax/">http://api.jquery.com/jQuery.ajax/</a>; here are several that you will use frequently:</p>
                                <ul>
                                    <li><code>async</code>: Set to <code>false</code> if the request should be sent synchronously. Defaults to <code>true</code>. Note that if you set this option to <code>false</code>, your request will block execution of other code until the response is received.</li>

                                    <li><code>cache</code>: Whether to use a cached response if available. Defaults to <code>true</code> for all <code>dataType</code>s except "script" and "jsonp". When set to <code>false</code>, the URL will simply have a cachebusting parameter appended to it.</li>

                                    <li><code>done</code>: A callback function to run if the request succeeds. The function receives the response data (converted to a JavaScript object if the dataType was JSON), as well as the text status of the request and the raw request object.</li>

                                    <li><code>fail</code>: A callback function to run if the request results in an error. The function receives the raw request object and the text status of the request.</li>

                                    <li><code>always</code>: A callback function to run when the request is complete, regardless of success or failure. The function receives the raw request object and the text status of the request.</li>

                                    <li><code>context</code>: The scope in which the callback function(s) should run (i.e. what <code>this</code> will mean inside the callback function(s)). By default, <code>this</code> inside the callback function(s) refers to the object originally passed to <code>$.ajax()</code>.</li>

                                    <li><code>data</code>: The data to be sent to the server. This can either be an object or a query string, such as <code>foo=bar&amp;baz=bim</code>.</li>

                                    <li><code>dataType</code>: The type of data you expect back from the server. By default, jQuery will look at the MIME type of the response if no <code>dataType</code> is specified.</li>

                                    <li><code>jsonp</code>: The callback name to send in a query string when making a JSONP request. Defaults to "callback".</li>

                                    <li><code>timeout</code>: The time in milliseconds to wait before considering the request a failure.</li>

                                    <li><code>traditional</code>: Set to <code>true</code> to use the param serialization style in use prior to jQuery 1.4. For details, see <a href="http://api.jquery.com/jQuery.param/">http://api.jquery.com/jQuery.param/</a>.</li>

                                    <li><code>type</code>: The type of the request, "POST" or "GET". Defaults to "GET". Other request types, such as "PUT" and "DELETE" can be used, but they may not be supported by all browsers.</li>

                                    <li><code>url</code>: The URL for the request.</li>
                                </ul>
                                
                                <p>The <code>url</code> option is the only required property of the <code>$.ajax()</code> configuration object; all other properties are optional. This can also be passed as the first argument to <code>$.ajax()</code>, and the options object as the second argument.</p>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Convenience-Methods">Convenience Methods - <code>$.get</code>, <code>$.post</code>, <code>$.getScript</code>, <code>$.getJSON</code></span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/jquery-ajax-methods/#convenience-methods">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>If you don't need the extensive configurability of <code>$.ajax()</code>, and you don't care about handling errors, the Ajax convenience functions provided by jQuery can be useful, terse ways to accomplish Ajax requests. These methods are just "wrappers" around the core <code>$.ajax()</code> method, and simply pre-set some of the options on the <code>$.ajax()</code> method.</p>

                                <p>The convenience methods provided by jQuery are:</p>
                                <ul>
                                    <li><code>$.get</code>: Perform a GET request to the provided URL.</li>

                                    <li><code>$.post</code>: Perform a POST request to the provided URL.</li>

                                    <li><code>$.getScript</code>: Add a script to the page.</li>

                                    <li><code>$.getJSON</code>: Perform a GET request, and expect JSON to be returned.</li>
                                </ul>
                                
                                <p>In each case, the methods take the following arguments, in order:</p>
                                <ul>
                                    <li><code>url</code>: The URL for the request. Required.</li>

                                    <li><code>data</code>: The data to be sent to the server. Optional. This can either be an object or a query string, such as <code>foo=bar&amp;baz=bim</code>.</li>

                                    <p>Note: This option is not valid for <code>$.getScript</code>.</p>

                                    <li><code>success callback</code>: A callback function to run if the request succeeds. Optional. The function receives the response data (converted to a JavaScript object if the data type was JSON), as well as the text status of the request and the raw request object.</li>

                                    <li><code>type</code>: The type of data you expect back from the server. Optional.</li>

                                    <p>Note: This option is only applicable for methods that don't already specify the data type in their name.</p>
                                </ul>
                                
                                <pre><code>
                                // Using jQuery's Ajax convenience methods
 
                                // Get plain text or HTML
                                $.get( "/users.php", {
                                    userId: 1234
                                }, function( resp ) {
                                    console.log( resp ); // server response
                                });

                                // Add a script to the page, then run a function defined in it
                                $.getScript( "/static/js/myScript.js", function() {
                                    functionFromMyScript();
                                });

                                // Get JSON-formatted data from the server
                                $.getJSON( "/details.php", function( resp ) {

                                    // Log each key in the response data
                                    $.each( resp, function( key, value ) {
                                        console.log( key + " : " + value );
                                    });
                                });
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="fn-load"><code>$.fn.load</code></span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/jquery-ajax-methods/#fn-load">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>The <code>.load()</code> method is unique among jQuery’s Ajax methods in that it is called on a selection. The <code>.load()</code> method fetches HTML from a URL, and uses the returned HTML to populate the selected element(s). In addition to providing a URL to the method, you can optionally provide a selector; jQuery will fetch only the matching content from the returned HTML.</p>
                                <pre><code>
                                // Using .load() to populate an element
                                $( "#newContent" ).load( "/foo.html" );

                                // Using .load() to populate an element based on a selector
                                $( "#newContent" ).load( "/foo.html #myDiv h1:first", function( html ) {
                                    alert( "Content updated!" );
                                });
                                </code></pre>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Ajax-and-Forms">Ajax and Forms</span>
                            <span class="source"><a href="https://learn.jquery.com/ajax/ajax-and-forms/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>jQuery's ajax capabilities can be especially useful when dealing with forms. There are several advantages, which can range from serialization, to simple client-side validation (e.g. "Sorry, that username is taken"), to <a href="http://api.jquery.com/jQuery.ajaxPrefilter/">prefilters</a>, and even more!</p>
                            
                            <h4 class="heading">
                                <span id="Serialization">Serialization</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/ajax-and-forms/#serialization">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Serializing form inputs in jQuery is extremely easy. Two methods come supported natively: <code>.serialize()</code> and <code>.serializeArray()</code>. While the names are fairly self-explanatory, there are many advantages to using them.</p>

                                <p>The <code>.serialize()</code> method serializes a form's data into a query string. For the element's value to be serialized, it must have a name attribute. Please note that values from inputs with a type of <code>checkbox</code> or <code>radio</code> are included only if they are checked.</p>
                                <pre><code>
                                // Turning form data into a query string
                                $( "#myForm" ).serialize();

                                // Creates a query string like this:
                                // field_1=something&field2=somethingElse
                                </code></pre>
                                
                                <p>While plain old serialization is great, sometimes your application would work better if you sent over an array of objects, instead of just the query string. For that, jQuery has the <code>.serializeArray()</code> method. It's very similar to the <code>.serialize()</code> method listed above, except it produces an array of objects, instead of a string.</p>
                                <pre><code>
                                // Creating an array of objects containing form data
                                $( "#myForm" ).serializeArray();

                                // Creates a structure like this:
                                // [
                                //   {
                                //     name : "field_1",
                                //     value : "something"
                                //   },
                                //   {
                                //     name : "field_2",
                                //     value : "somethingElse"
                                //   }
                                // ]
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Client-side-validation">Client-side validation</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/ajax-and-forms/#client-side-validation">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>Client-side validation is, much like many other things, extremely easy using jQuery. While there are several cases developers can test for, some of the most common ones are: presence of a required input, valid usernames/emails/phone numbers/etc…, or checking an "I agree…" box.</p>

                                <p>Please note that it is advisable that you also perform server-side validation for your inputs. However, it typically makes for a better user experience to be able to validate some things without submitting the form.</p>

                                <p>With that being said, let's jump on in to some examples! First, we'll see how easy it is to check if a required field doesn't have anything in it. If it doesn't, then we'll return <code>false</code>, and prevent the form from processing.</p>
                                <pre><code>
                                // Using validation to check for the presence of an input
                                $( "#form" ).submit(function( event ) {

                                    // If .required's value's length is zero
                                    if ( $( ".required" ).val().length === 0 ) {

                                        // Usually show some kind of error message here

                                        // Prevent the form from submitting
                                        event.preventDefault();
                                    } else {

                                        // Run $.ajax() here
                                    }
                                });
                                </code></pre>
                                <p>Let's see how easy it is to check for invalid characters in a phone number:</p>
                                <pre><code>
                                // Validate a phone number field
                                $( "#form" ).submit(function( event ) {
                                    var inputtedPhoneNumber = $( "#phone" ).val();

                                    // Match only numbers
                                    var phoneNumberRegex = /^\d*$/;

                                    // If the phone number doesn't match the regex
                                    if ( !phoneNumberRegex.test( inputtedPhoneNumber ) ) {

                                        // Usually show some kind of error message here

                                        // Prevent the form from submitting
                                        event.preventDefault();
                                    } else {

                                        // Run $.ajax() here
                                    }
                                });
                                </code></pre>
                            </div>
                            
                            <h4 class="heading">
                                <span id="Prefiltering">Prefiltering</span>
                                <span class="source"><a href="https://learn.jquery.com/ajax/ajax-and-forms/#prefiltering">Source</a></span>
                            </h4>
                            <div class="content">
                                <p>A prefilter is a way to modify the ajax options before each request is sent (hence, the name prefilter).</p>

                                <p>For example, say we would like to modify all cross-domain requests through a proxy. To do so with a prefilter is quite simple:</p>
                                <pre><code>
                                // Using a proxy with a prefilter
                                $.ajaxPrefilter(function( options, originalOptions, jqXHR ) {
                                    if ( options.crossDomain ) {
                                        options.url = "http://mydomain.net/proxy/" + encodeURIComponent( options.url );
                                        options.crossDomain = false;
                                    }
                                });
                                </code></pre>
                                
                                <p>You can pass in an optional argument before the callback function that specifies which <code>dataTypes</code> you'd like the prefilter to be applied to. For example, if we want our prefilter to only apply to JSON and script requests, we'd do:</p>
                                <pre><code>
                                // Using the optional dataTypes argument
                                $.ajaxPrefilter( "json script", function( options, originalOptions, jqXHR ) {

                                    // Do all of the prefiltering here, but only for
                                    // requests that indicate a dataType of "JSON" or "script"
                                });
                                </code></pre>
                            </div>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Working-with-JSONP">Working with JSONP</span>
                            <span class="source"><a href="https://learn.jquery.com/ajax/working-with-jsonp/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>The advent of JSONP — essentially a consensual cross-site scripting hack — has opened the door to powerful mashups of content. Many prominent sites provide JSONP services, allowing you access to their content via a predefined API. A particularly great source of JSONP-formatted data is the <a href="http://developer.yahoo.com/yql/console/">Yahoo! Query Language</a>, which we'll use in the following example to fetch news about cats.</p>
                            <pre><code>
                            // Using YQL and JSONP
                            $.ajax({
                                url: "http://query.yahooapis.com/v1/public/yql",

                                // The name of the callback parameter, as specified by the YQL service
                                jsonp: "callback",

                                // Tell jQuery we're expecting JSONP
                                dataType: "jsonp",

                                // Tell YQL what we want and that we want JSON
                                data: {
                                    q: "select title,abstract,url from search.news where query=\"cat\"",
                                    format: "json"
                                },

                                // Work with the response
                                success: function( response ) {
                                    console.log( response ); // server response
                                }
                            });
                            </code></pre>
                            
                            <p>jQuery handles all the complex aspects of JSONP behind-the-scenes — all we have to do is tell jQuery the name of the JSONP callback parameter specified by YQL ("callback" in this case), and otherwise the whole process looks and feels like a normal Ajax request.</p>
                        </div>
                        
                        <h3 class="heading">
                            <span id="Ajax-Events">Ajax Events</span>
                            <span class="source"><a href="https://learn.jquery.com/ajax/ajax-events/">Source</a></span>
                        </h3>
                        <div class="content">
                            <p>Often, you'll want to perform an operation whenever an Ajax request starts or stops, such as showing or hiding a loading indicator. Rather than defining this behavior inside every Ajax request, you can bind Ajax events to elements just like you'd bind other events. For a complete list of Ajax events, visit <a href="http://docs.jquery.com/Ajax_Events">Ajax Events documentation on docs.jquery.com</a>.</p>
                            <pre><code>
                            // Setting up a loading indicator using Ajax Events
                            $( "#loading_indicator" )
                                .ajaxStart(function() {
                                    $( this ).show();
                                })
                                .ajaxStop(function() {
                                    $( this ).hide();
                                });
                            </code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </body>
</html>